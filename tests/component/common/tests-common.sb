#include "linux.sbh"
#include "tests-common.sbh"

// realistically not all registers need to be saved but this is a safe approach for now.
fun linux_write(u32 fd, u8 *buf, u64 count) asm
{
	addi sp, sp, -256
	sd ra, 0(sp)
	sd sp, 8(sp)
	sd gp, 16(sp)
	sd tp, 24(sp)
	sd t0, 32(sp)
	sd t1, 40(sp)
	sd t2, 48(sp)
	sd s0, 56(sp)
	sd s1, 64(sp)
	sd a0, 72(sp)
	sd a1, 88(sp)
	sd a2, 96(sp)
	sd a3, 104(sp)
	sd a4, 112(sp)
	sd a5, 120(sp)
	sd a6, 128(sp)
	sd a7, 136(sp)
	sd s2, 144(sp)
	sd s3, 152(sp)
	sd s4, 160(sp)
	sd s5, 168(sp)
	sd s6, 176(sp)
	sd s7, 184(sp)
	sd s8, 192(sp)
	sd s9, 200(sp)
	sd s10, 208(sp)
	sd s11, 216(sp)
	sd t3, 224(sp)
	sd t4, 232(sp)
	sd t5, 240(sp)
	sd t6, 248(sp)

	t0 = readvar(fd)
	t1 = readvar(buf)
	t2 = readvar(count)

	li a7, LINUX_RISCV_WRITE
	mv a0, t0
	mv a1, t1
	mv a2, t2
	ecall

	ld ra, 0(sp)
	ld sp, 8(sp)
	ld gp, 16(sp)
	ld tp, 24(sp)
	ld t0, 32(sp)
	ld t1, 40(sp)
	ld t2, 48(sp)
	ld s0, 56(sp)
	ld s1, 64(sp)
	ld a0, 72(sp)
	ld a1, 88(sp)
	ld a2, 96(sp)
	ld a3, 104(sp)
	ld a4, 112(sp)
	ld a5, 120(sp)
	ld a6, 128(sp)
	ld a7, 136(sp)
	ld s2, 144(sp)
	ld s3, 152(sp)
	ld s4, 160(sp)
	ld s5, 168(sp)
	ld s6, 176(sp)
	ld s7, 184(sp)
	ld s8, 192(sp)
	ld s9, 200(sp)
	ld s10, 208(sp)
	ld s11, 216(sp)
	ld t3, 224(sp)
	ld t4, 232(sp)
	ld t5, 240(sp)
	ld t6, 248(sp)
	addi sp, sp, 256
}

fun putc(u8 c) 
{
	linux_write(1, &c, 1);
}

fun printNum(u64 value, u8 newline)
{
	u8[21] chars;
	u8 nChars = 0;
	u64 vc = value;
	if(value == 0)
	{
		chars[0] = '0';
		nChars = 1;
	}

	while(value > 0)
	{
		u8 rv = value % 10;
		chars[nChars] = rv + '0';
		value /= 10;
		nChars += 1;
		chars[nChars] = 0;
	}
	
	while(nChars > 0)
	{
		putc(chars[nChars - 1]);
		nChars -= 1;
	}

	if(newline)
	{
		putc('\n');
	}
}

fun printHex(u64 value, u8 newline)
{
	putc('0');
	putc('x');
	u8 i = 0;
	while(i < 8)
	{
		u8 thisByte = (value >> ((7 - i) * 8)) & 0xff;
		u8 j = 0;
		while(j < 2)
		{
			u8 thisNibble = (thisByte >> ((1 - j) * 4)) & 0xf;
			if(thisNibble < 10)
			{
				putc('0' + thisNibble);
			}
			else
			{
				putc('A' + (thisNibble- 10));
			}
			j = j + 1;
		}


		i = i + 1;
	}

	if(newline)
	{
		putc('\n');
	}
}

u32 fun printStr(u8 *str)
{
	u32 idx = 0;
	while(str[idx] != 0)
	{
		putc(str[idx]);
		idx = idx + 1;
	}
	return idx;
}

/*
FINISHER_FAIL = 0x3333,
FINISHER_PASS = 0x5555,
FINISHER_RESET = 0x7777
*/
fun exit() asm
{
	li a7, 93
	li a0, 0
	ecall
}
