<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","mod.rs"],"content":"mod regalloc;\n\nuse crate::midend::*;\n\npub fn generate_code_for_function(function: \u0026mut symtab::Function) {\n    println!(\"generate code for {}\", function.prototype);\n    regalloc::allocate_registers(\u0026function.scope, \u0026function.control_flow);\n}\n\npub fn generate_code(mut symbol_table: symtab::SymbolTable) {\n    for (_, member) in \u0026mut symbol_table.functions {\n        match member {\n            symtab::FunctionOrPrototype::Function(f) =\u003e generate_code_for_function(f),\n            symtab::FunctionOrPrototype::Prototype(p) =\u003e println!(\"{}\", p),\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","block_depths.rs"],"content":"use std::{\n    collections::{BTreeMap, VecDeque},\n    usize,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\nstruct BlockDepthMetadata\u003c'a\u003e {\n    depths: BTreeMap\u003cusize, usize\u003e,\n    control_flow: \u0026'a ir::ControlFlow,\n    unknown_predecessors_worklist: VecDeque\u003cusize\u003e,\n}\nimpl\u003c'a\u003e BlockDepthMetadata\u003c'a\u003e {\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            depths: BTreeMap::new(),\n            control_flow,\n            unknown_predecessors_worklist: VecDeque::new(),\n        }\n    }\n\n    fn set_block_depth(\u0026mut self, block_label: usize, depth: usize) {\n        self.depths.insert(block_label, depth);\n    }\n\n    fn max_of_predecessors(\u0026mut self, block_label: usize) -\u003e usize {\n        let mut max = usize::MIN;\n\n        for predecessor_label in \u0026self.control_flow.block_for_label(\u0026block_label).predecessors {\n            let predecessor_depth = match self.depths.get(predecessor_label) {\n                Some(depth) =\u003e *depth,\n                None =\u003e {\n                    self.unknown_predecessors_worklist\n                        .push_back(*predecessor_label);\n                    usize::MIN\n                }\n            };\n\n            max = usize::max(predecessor_depth, max);\n        }\n\n        max\n    }\n\n    fn visit(\u0026mut self, block_label: usize) {\n        let max_predecessor_depth = self.max_of_predecessors(block_label);\n        self.set_block_depth(block_label, max_predecessor_depth + 1);\n    }\n}\n\npub fn find_block_depths(control_flow: \u0026ir::ControlFlow) -\u003e BTreeMap\u003cusize, usize\u003e {\n    let mut metadata = BlockDepthMetadata::new(control_flow);\n\n    for (label, _) in control_flow.blocks_postorder() {\n        metadata.visit(label);\n    }\n\n    while let Some(unvisited) = metadata.unknown_predecessors_worklist.pop_front() {\n        metadata.visit(unvisited);\n    }\n\n    metadata.depths\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","lifetime.rs"],"content":"use std::{\n    cmp::Ordering,\n    collections::{BTreeMap, HashMap},\n    fmt,\n};\n\nuse crate::midend;\n\nuse super::program_point::ProgramPoint;\n\n#[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]\npub struct Lifetime {\n    pub name: midend::ir::OperandName,\n    pub start: usize,\n    pub end: usize,\n    pub n_reads: usize,\n    pub n_writes: usize,\n}\n\nimpl Lifetime {\n    pub fn new(name: midend::ir::OperandName) -\u003e Self {\n        Lifetime {\n            name: name,\n            start: usize::MAX,\n            end: usize::MIN,\n            n_reads: 0,\n            n_writes: 0,\n        }\n    }\n\n    fn update_range(\u0026mut self, potential_range_limit: \u0026usize) {\n        if *potential_range_limit \u003c self.start {\n            self.start = *potential_range_limit;\n        }\n        if self.end \u003c *potential_range_limit {\n            self.end = *potential_range_limit;\n        }\n    }\n\n    pub fn record_read(\u0026mut self, at_index: \u0026usize) {\n        self.n_reads += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn record_write(\u0026mut self, at_index: \u0026usize) {\n        self.n_writes += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn live_at(\u0026self, at_index: \u0026usize) -\u003e bool {\n        (self.start \u003c= *at_index) \u0026\u0026 (self.end \u003e= *at_index)\n    }\n}\n\nimpl std::fmt::Display for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}: {}-{}]\", self.name, self.start, self.end)\n    }\n}\n\npub struct LifetimeSet {\n    pub lifetimes: HashMap\u003cmidend::ir::OperandName, Lifetime\u003e,\n}\n\nimpl LifetimeSet {\n    fn new() -\u003e Self {\n        LifetimeSet {\n            lifetimes: HashMap::\u003cmidend::ir::OperandName, Lifetime\u003e::new(),\n        }\n    }\n\n    pub fn from_block(block: \u0026midend::ir::BasicBlock) -\u003e Self {\n        let mut lifetimes = Self::new();\n\n        for (index, line) in block.statements.iter().enumerate() {\n            for read_operand in line.read_operand_names() {\n                lifetimes.record_read_at_index(read_operand, \u0026index);\n            }\n\n            for write_operand in line.write_operand_names() {\n                lifetimes.record_write_at_index(write_operand, \u0026index);\n            }\n        }\n\n        lifetimes\n    }\n\n    fn lookup_or_create_lifetime_by_name(\n        \u0026mut self,\n        name: \u0026midend::ir::OperandName,\n    ) -\u003e \u0026mut Lifetime {\n        if !self.lifetimes.contains_key(name) {\n            self.lifetimes\n                .insert(name.clone(), Lifetime::new(name.clone()));\n        }\n\n        self.lifetimes.get_mut(name).unwrap()\n    }\n\n    pub fn record_read_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_read(index);\n    }\n\n    pub fn record_write_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_write(index);\n    }\n\n    pub fn values(\n        \u0026self,\n    ) -\u003e std::collections::hash_map::Values\u003c'_, midend::ir::OperandName, Lifetime\u003e {\n        self.lifetimes.values()\n    }\n\n    pub fn print_numerical(\u0026self) {\n        for lifetime in self.lifetimes.values() {\n            println!(\n                \"{:\u003e20}: [{}-{}]\",\n                lifetime.name, lifetime.start, lifetime.end\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::{backend::regalloc::program_point::ProgramPoint, midend};\n\n    use super::Lifetime;\n\n    #[test]\n    fn test_lifetime_range() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        dummy_lifetime.record_read(\u00261);\n\n        assert!(dummy_lifetime.start == 1);\n        assert!(dummy_lifetime.start == dummy_lifetime.end);\n\n        dummy_lifetime.record_write(\u00260);\n\n        assert!(dummy_lifetime.start == 0);\n        assert!(dummy_lifetime.end == 1);\n    }\n\n    #[test]\n    fn test_lifetime_format() {\n        let mut dummy_lifetime =\n            Lifetime::new(midend::ir::OperandName::new_basic(\"my_variable\".into()));\n\n        let start_point = 2;\n        let end_point = 4;\n\n        dummy_lifetime.record_write(\u0026start_point);\n        dummy_lifetime.record_write(\u0026end_point);\n\n        assert_eq!(\n            format!(\"{}\", dummy_lifetime),\n            format!(\"[my_variable: {}-{}]\", start_point, end_point)\n        );\n    }\n\n    #[test]\n    fn test_lifetime_live_at() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        assert!(!dummy_lifetime.live_at(\u00260));\n        dummy_lifetime.record_write(\u00260);\n        dummy_lifetime.record_write(\u00265);\n\n        for index in 0..5 {\n            assert!(dummy_lifetime.live_at(\u0026index));\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":44},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","mod.rs"],"content":"use std::collections::{BTreeMap, BTreeSet};\n\nuse block_depths::*;\nuse lifetime::{Lifetime, LifetimeSet};\nuse program_point::ProgramPoint;\n\nuse crate::midend::{self, ir::ControlFlow, symtab};\n\nmod block_depths;\nmod lifetime;\nmod program_point;\n\nfn record_interference_graph(\n    graph: \u0026mut BTreeMap\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e,\n    lifetime_a: \u0026midend::ir::OperandName,\n    lifetime_b: \u0026midend::ir::OperandName,\n) {\n    graph\n        .entry(lifetime_a.clone())\n        .or_default()\n        .insert(lifetime_b.clone());\n}\n\npub fn allocate_registers(_scope: \u0026symtab::Scope, control_flow: \u0026ControlFlow) {\n    println!(\"Allocate registers for scope\");\n\n    // let depths = find_block_depths(control_flow);\n\n    let mut graph = BTreeMap::\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e::new();\n\n    for (_, block) in \u0026control_flow.blocks {\n        let block_lifetimes = LifetimeSet::from_block(block);\n\n        for index in 0..block.statements.len() {\n            let mut first_iter = block_lifetimes.lifetimes.iter();\n\n            while let Some((first_name, first_lt)) = first_iter.next() {\n                if first_lt.live_at(\u0026index) {\n                    let mut second_iter = first_iter.clone();\n                    while let Some((second_name, second_lt)) = second_iter.next() {\n                        if second_lt.live_at(\u0026index) {\n                            record_interference_graph(\u0026mut graph, first_name, second_name);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","program_point.rs"],"content":"use core::fmt;\nuse std::cmp::Ordering;\n\nuse serde::Serialize;\n\n#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Serialize, Hash)]\npub struct ProgramPoint {\n    pub depth: usize, // depth in the DFS traversal of control flow\n    pub index: usize, // index within a basic block\n}\n\nimpl ProgramPoint {\n    pub fn default() -\u003e Self {\n        Self::new(0, 0)\n    }\n\n    pub fn new(depth: usize, index: usize) -\u003e Self {\n        ProgramPoint { depth, index }\n    }\n}\n\nimpl std::fmt::Display for ProgramPoint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:\u003e2x}:{:\u003c2x}\", self.depth, self.index)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::backend::regalloc::program_point::ProgramPoint;\n\n    #[test]\n    fn test_default() {\n        let default_point = ProgramPoint::default();\n\n        assert_eq!(default_point.depth, 0);\n        assert_eq!(default_point.index, 0);\n    }\n\n    #[test]\n    fn test_partial_ord_eq() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.partial_cmp(\u0026point_2), Some(Ordering::Greater));\n        assert_eq!(point_1.partial_cmp(\u0026point_3), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_ord() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.cmp(\u0026point_2), Ordering::Greater);\n        assert_eq!(point_1.cmp(\u0026point_3), Ordering::Equal);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":7}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","ast.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend};\nuse std::fmt::Display;\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum TranslationUnit {\n    FunctionDeclaration(FunctionDeclarationTree),\n    FunctionDefinition(FunctionDefinitionTree),\n}\n\nimpl Display for TranslationUnit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::FunctionDeclaration(function_declaration) =\u003e {\n                write!(f, \"Function Declaration: {}\", function_declaration)\n            }\n            Self::FunctionDefinition(function_definition) =\u003e {\n                write!(f, \"Function Definition: {}\", function_definition)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TranslationUnitTree {\n    pub loc: SourceLoc,\n    pub contents: TranslationUnit,\n}\nimpl Display for TranslationUnitTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Translation Unit: {}\", self.contents)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub arguments: Vec\u003cVariableDeclarationTree\u003e,\n    pub return_type: Option\u003cTypenameTree\u003e,\n}\nimpl Display for FunctionDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arg_string = String::from(\"\");\n        for argument in \u0026self.arguments {\n            arg_string.push_str(format!(\"{}\\n\", argument).as_str());\n        }\n\n        match \u0026self.return_type {\n            Some(typename_tree) =\u003e write!(\n                f,\n                \"Function Declaration: {}({})-\u003e{}\",\n                self.name, arg_string, typename_tree\n            ),\n            None =\u003e write!(f, \"Function Declaration: {}({})\", self.name, arg_string),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDefinitionTree {\n    pub prototype: FunctionDeclarationTree,\n    pub body: CompoundStatementTree,\n}\nimpl Display for FunctionDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Function Definition: {}, {}\", self.prototype, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct CompoundStatementTree {\n    pub loc: SourceLoc,\n    pub statements: Vec\u003cStatementTree\u003e,\n}\nimpl Display for CompoundStatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut statement_string = String::from(\"\");\n        for statement in \u0026self.statements {\n            statement_string.push_str(format!(\"{}\\n\", statement).as_str());\n        }\n        write!(f, \"Compound Statement: {}\", statement_string)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct IfStatementTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub true_block: CompoundStatementTree,\n    pub false_block: Option\u003cCompoundStatementTree\u003e,\n}\nimpl Display for IfStatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self.false_block {\n            Some(false_block) =\u003e write!(\n                f,\n                \"if {}\\n\\t{{{}}} else {{{}}}\",\n                self.condition, self.true_block, false_block\n            ),\n            None =\u003e write!(f, \"if {}\\n\\t{{{}}}\", self.condition, self.true_block),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct WhileLoopTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub body: CompoundStatementTree,\n}\nimpl Display for WhileLoopTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"while ({}) {}\", self.condition, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Statement {\n    VariableDeclaration(VariableDeclarationTree),\n    Assignment(AssignmentTree),\n    IfStatement(IfStatementTree),\n    WhileLoop(WhileLoopTree),\n}\n\nimpl Display for Statement {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::VariableDeclaration(variable_declaration) =\u003e {\n                write!(f, \"{}\", variable_declaration)\n            }\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{}\", assignment)\n            }\n            Self::IfStatement(if_statement) =\u003e {\n                write!(f, \"{}\", if_statement)\n            }\n            Self::WhileLoop(while_loop) =\u003e {\n                write!(f, \"{}\", while_loop)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StatementTree {\n    pub loc: SourceLoc,\n    pub statement: Statement,\n}\nimpl Display for StatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.statement)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct VariableDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub typename: TypenameTree,\n}\nimpl Display for VariableDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.typename)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct AssignmentTree {\n    pub loc: SourceLoc,\n    pub identifier: String,\n    pub value: ExpressionTree,\n}\nimpl Display for AssignmentTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} = {}\", self.identifier, self.value)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ArithmeticDualOperands {\n    pub e1: Box\u003cExpressionTree\u003e,\n    pub e2: Box\u003cExpressionTree\u003e,\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ArithmeticOperationTree {\n    Add(ArithmeticDualOperands),\n    Subtract(ArithmeticDualOperands),\n    Multiply(ArithmeticDualOperands),\n    Divide(ArithmeticDualOperands),\n}\nimpl Display for ArithmeticOperationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e write!(f, \"({} + {})\", operands.e1, operands.e2),\n            Self::Subtract(operands) =\u003e write!(f, \"({} - {})\", operands.e1, operands.e2),\n            Self::Multiply(operands) =\u003e write!(f, \"({} * {})\", operands.e1, operands.e2),\n            Self::Divide(operands) =\u003e write!(f, \"({} / {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ComparisonOperationTree {\n    LThan(ArithmeticDualOperands),\n    GThan(ArithmeticDualOperands),\n    LThanE(ArithmeticDualOperands),\n    GThanE(ArithmeticDualOperands),\n    Equals(ArithmeticDualOperands),\n    NotEquals(ArithmeticDualOperands),\n}\nimpl Display for ComparisonOperationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LThan(operands) =\u003e write!(f, \"({} \u003c {})\", operands.e1, operands.e2),\n            Self::GThan(operands) =\u003e write!(f, \"({} \u003e {})\", operands.e1, operands.e2),\n            Self::LThanE(operands) =\u003e write!(f, \"({} \u003c= {})\", operands.e1, operands.e2),\n            Self::GThanE(operands) =\u003e write!(f, \"({} \u003e= {})\", operands.e1, operands.e2),\n            Self::Equals(operands) =\u003e write!(f, \"({} == {})\", operands.e1, operands.e2),\n            Self::NotEquals(operands) =\u003e write!(f, \"({} != {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Expression {\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Arithmetic(ArithmeticOperationTree),\n    Comparison(ComparisonOperationTree),\n}\nimpl Display for Expression {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Identifier(identifier) =\u003e write!(f, \"{}\", identifier),\n            Self::UnsignedDecimalConstant(constant) =\u003e write!(f, \"{}\", constant),\n            Self::Arithmetic(operation) =\u003e write!(f, \"{}\", operation),\n            Self::Comparison(operation) =\u003e write!(f, \"{}\", operation),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ExpressionTree {\n    pub loc: SourceLoc,\n    pub expression: Expression,\n}\nimpl Display for ExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.expression)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TypenameTree {\n    pub loc: SourceLoc,\n    pub type_: midend::types::Type,\n}\n\nimpl Display for TypenameTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.type_)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":19}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":5}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":25}},{"line":194,"address":[],"length":0,"stats":{"Line":25}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":5}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":73}},{"line":234,"address":[],"length":0,"stats":{"Line":73}},{"line":235,"address":[],"length":0,"stats":{"Line":15}},{"line":236,"address":[],"length":0,"stats":{"Line":30}},{"line":237,"address":[],"length":0,"stats":{"Line":25}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":73}},{"line":250,"address":[],"length":0,"stats":{"Line":73}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":1}}],"covered":42,"coverable":72},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","integration_tests.rs"],"content":"use crate::frontend::lexer::Lexer;\n\nuse super::token::Token;\n\nfn assert_single_tokenization(input_str: \u0026str, expected_token: Token) {\n    println!(\n        \"Assert single tokenization against {} == {}\",\n        input_str, expected_token\n    );\n    let result = Lexer::new(String::from(input_str).chars()).lex_all();\n    assert_eq!(result, vec! {expected_token, Token::Eof});\n}\n\n#[test]\nfn tokenize_l_curly() {\n    assert_single_tokenization(\"{\", Token::LCurly);\n}\n\n#[test]\nfn tokenize_r_curly() {\n    assert_single_tokenization(\"}\", Token::RCurly);\n}\n\n#[test]\nfn tokenize_identifier() {\n    assert_single_tokenization(\"abc\", Token::Identifier(String::from(\"abc\")));\n    assert_single_tokenization(\"abc123\", Token::Identifier(String::from(\"abc123\")));\n    assert_single_tokenization(\"abc123def\", Token::Identifier(String::from(\"abc123def\")));\n    assert_single_tokenization(\n        \"unsignedOrSomething_123\",\n        Token::Identifier(String::from(\"unsignedOrSomething_123\")),\n    );\n    assert_single_tokenization(\n        \"u16_named_fred\",\n        Token::Identifier(String::from(\"u16_named_fred\")),\n    );\n}\n\n#[test]\nfn tokenize_unsigned_decimal_constant() {\n    assert_single_tokenization(\"123\", Token::UnsignedDecimalConstant(123));\n    assert_single_tokenization(\n        \u0026usize::MAX.to_string(),\n        Token::UnsignedDecimalConstant(usize::MAX),\n    );\n    assert_single_tokenization(\n        \u0026usize::MIN.to_string(),\n        Token::UnsignedDecimalConstant(usize::MIN),\n    );\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":10}},{"line":6,"address":[],"length":0,"stats":{"Line":10}},{"line":7,"address":[],"length":0,"stats":{"Line":10}},{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":10,"address":[],"length":0,"stats":{"Line":10}},{"line":11,"address":[],"length":0,"stats":{"Line":10}}],"covered":6,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","mod.rs"],"content":"use token::Token;\n\nuse super::sourceloc::SourceLoc;\n\nmod integration_tests;\nmod tests;\npub mod token;\n\npub struct Lexer\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    cur_line: usize,\n    cur_col: usize,\n    current_char: Option\u003cchar\u003e,\n    current_token: Option\u003cToken\u003e,\n    input: I,\n}\n\nimpl\u003cI\u003e Lexer\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    fn peek_char(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.current_char\n    }\n\n    fn advance_char(\u0026mut self) {\n        if let Some(consumed) = self.current_char {\n            if consumed == '\\n' {\n                self.cur_line += 1;\n                self.cur_col = 1;\n            } else {\n                self.cur_col += 1;\n            }\n        }\n        self.current_char = self.input.next();\n    }\n\n    fn invalid_char(\u0026self, char: char) {\n        panic!(\"Invalid character '{}' at {}\", char, self.current_loc());\n    }\n\n    fn from_iterator(iterator: I) -\u003e Self {\n        Self {\n            cur_line: 1,\n            cur_col: 1,\n            current_char: None,\n            current_token: None,\n            input: iterator,\n        }\n    }\n\n    pub fn new(input: I) -\u003e Self {\n        let mut created = Self::from_iterator(input);\n        created.advance_char();\n        created.next();\n        return created;\n    }\n\n    fn match_kw_or_ident(\u0026mut self) -\u003e Token {\n        let mut identifier = String::new();\n\n        while let Some(c) = self.peek_char() {\n            if c.is_alphanumeric() || c == '_' {\n                identifier.push(c);\n                self.advance_char();\n            } else {\n                break;\n            }\n        }\n        match identifier.as_str() {\n            \"u8\" =\u003e Token::U8,\n            \"u16\" =\u003e Token::U16,\n            \"u32\" =\u003e Token::U32,\n            \"u64\" =\u003e Token::U64,\n            \"i8\" =\u003e Token::I8,\n            \"i16\" =\u003e Token::I16,\n            \"i32\" =\u003e Token::I32,\n            \"i64\" =\u003e Token::I64,\n            \"fun\" =\u003e Token::Fun,\n            \"if\" =\u003e Token::If,\n            \"else\" =\u003e Token::Else,\n            \"while\" =\u003e Token::While,\n            \"pub\" =\u003e Token::Pub,\n            \"struct\" =\u003e Token::Struct,\n            _ =\u003e Token::Identifier(identifier),\n        }\n    }\n\n    pub fn peek(\u0026self) -\u003e Token {\n        self.current_token.clone().unwrap_or(Token::Eof)\n    }\n\n    pub fn current_loc(\u0026self) -\u003e SourceLoc {\n        SourceLoc::new(self.cur_line, self.cur_col)\n    }\n\n    fn match_next_char_for_token_or(\n        \u0026mut self,\n        expected: char,\n        tok_true: Token,\n        tok_false: Token,\n    ) -\u003e Token {\n        match self.peek_char() {\n            None =\u003e tok_false,\n            Some(char) =\u003e {\n                if char == expected {\n                    self.advance_char();\n                    tok_true\n                } else {\n                    tok_false\n                }\n            }\n        }\n    }\n\n    fn lex(\u0026mut self) -\u003e Token {\n        while self.peek_char().is_some() \u0026\u0026 self.peek_char().unwrap().is_whitespace() {\n            self.advance_char();\n        }\n\n        let token = if let Some(char) = self.peek_char() {\n            match char {\n                '{' =\u003e {\n                    self.advance_char();\n                    Token::LCurly\n                }\n                '}' =\u003e {\n                    self.advance_char();\n                    Token::RCurly\n                }\n                '(' =\u003e {\n                    self.advance_char();\n                    Token::LParen\n                }\n                ')' =\u003e {\n                    self.advance_char();\n                    Token::RParen\n                }\n                '+' =\u003e {\n                    self.advance_char();\n                    Token::Plus\n                }\n                '-' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('\u003e', Token::Arrow, Token::Minus)\n                }\n                '*' =\u003e {\n                    self.advance_char();\n                    Token::Star\n                }\n                '/' =\u003e {\n                    self.advance_char();\n                    Token::FSlash\n                }\n                '\u003e' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::GThanE, Token::GThan)\n                }\n                '\u003c' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::LThanE, Token::LThan)\n                }\n                '!' =\u003e {\n                    self.advance_char();\n                    match self.peek_char() {\n                        None =\u003e {\n                            self.invalid_char('!');\n                            Token::Eof\n                        }\n                        Some(char) =\u003e {\n                            if char == '=' {\n                                self.advance_char();\n                                Token::NotEquals\n                            } else {\n                                self.invalid_char('!');\n                                Token::Eof\n                            }\n                        }\n                    }\n                }\n                '=' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::Equals, Token::Assign)\n                }\n                ',' =\u003e {\n                    self.advance_char();\n                    Token::Comma\n                }\n                ';' =\u003e {\n                    self.advance_char();\n                    Token::Semicolon\n                }\n                ':' =\u003e {\n                    self.advance_char();\n                    Token::Colon\n                }\n                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' =\u003e {\n                    let mut constant_string = String::new();\n                    while self.peek_char().is_some() {\n                        let char: char = self.peek_char().unwrap();\n                        if char.is_numeric() {\n                            self.advance_char();\n                            constant_string.push(char);\n                        } else {\n                            break;\n                        }\n                    }\n                    Token::UnsignedDecimalConstant(\n                        usize::from_str_radix(\u0026constant_string, 10)\n                            .expect(\"Couldn't convert unsigned decimal constant\"),\n                    )\n                }\n                _ =\u003e self.match_kw_or_ident(),\n            }\n        } else {\n            Token::Eof\n        };\n        token\n    }\n\n    pub fn next(\u0026mut self) -\u003e Token {\n        let next_token = self.lex();\n        self.current_token.replace(next_token).unwrap_or(Token::Eof)\n    }\n\n    pub fn lex_all(\u0026mut self) -\u003e Vec\u003cToken\u003e {\n        let mut tokens: Vec\u003cToken\u003e = Vec::new();\n        loop {\n            let next_token = self.next();\n            match next_token {\n                Token::Eof =\u003e {\n                    tokens.push(next_token);\n                    break;\n                }\n                _ =\u003e {\n                    tokens.push(next_token);\n                }\n            }\n        }\n\n        tokens\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2019}},{"line":25,"address":[],"length":0,"stats":{"Line":2019}},{"line":28,"address":[],"length":0,"stats":{"Line":1048}},{"line":29,"address":[],"length":0,"stats":{"Line":1947}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":894}},{"line":37,"address":[],"length":0,"stats":{"Line":1048}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":150}},{"line":54,"address":[],"length":0,"stats":{"Line":74}},{"line":55,"address":[],"length":0,"stats":{"Line":74}},{"line":56,"address":[],"length":0,"stats":{"Line":74}},{"line":57,"address":[],"length":0,"stats":{"Line":74}},{"line":58,"address":[],"length":0,"stats":{"Line":74}},{"line":61,"address":[],"length":0,"stats":{"Line":136}},{"line":62,"address":[],"length":0,"stats":{"Line":136}},{"line":64,"address":[],"length":0,"stats":{"Line":1319}},{"line":65,"address":[],"length":0,"stats":{"Line":630}},{"line":66,"address":[],"length":0,"stats":{"Line":576}},{"line":67,"address":[],"length":0,"stats":{"Line":576}},{"line":69,"address":[],"length":0,"stats":{"Line":31}},{"line":72,"address":[],"length":0,"stats":{"Line":136}},{"line":73,"address":[],"length":0,"stats":{"Line":139}},{"line":74,"address":[],"length":0,"stats":{"Line":135}},{"line":75,"address":[],"length":0,"stats":{"Line":133}},{"line":76,"address":[],"length":0,"stats":{"Line":131}},{"line":77,"address":[],"length":0,"stats":{"Line":129}},{"line":78,"address":[],"length":0,"stats":{"Line":127}},{"line":79,"address":[],"length":0,"stats":{"Line":125}},{"line":80,"address":[],"length":0,"stats":{"Line":123}},{"line":81,"address":[],"length":0,"stats":{"Line":121}},{"line":82,"address":[],"length":0,"stats":{"Line":121}},{"line":83,"address":[],"length":0,"stats":{"Line":116}},{"line":84,"address":[],"length":0,"stats":{"Line":113}},{"line":85,"address":[],"length":0,"stats":{"Line":109}},{"line":86,"address":[],"length":0,"stats":{"Line":107}},{"line":87,"address":[],"length":0,"stats":{"Line":103}},{"line":91,"address":[],"length":0,"stats":{"Line":238}},{"line":92,"address":[],"length":0,"stats":{"Line":238}},{"line":95,"address":[],"length":0,"stats":{"Line":97}},{"line":96,"address":[],"length":0,"stats":{"Line":97}},{"line":99,"address":[],"length":0,"stats":{"Line":19}},{"line":105,"address":[],"length":0,"stats":{"Line":19}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":15}},{"line":108,"address":[],"length":0,"stats":{"Line":15}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":11}},{"line":118,"address":[],"length":0,"stats":{"Line":291}},{"line":119,"address":[],"length":0,"stats":{"Line":699}},{"line":120,"address":[],"length":0,"stats":{"Line":75}},{"line":123,"address":[],"length":0,"stats":{"Line":765}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":139,"address":[],"length":0,"stats":{"Line":10}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":143,"address":[],"length":0,"stats":{"Line":15}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":159,"address":[],"length":0,"stats":{"Line":5}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":7}},{"line":185,"address":[],"length":0,"stats":{"Line":7}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":51}},{"line":201,"address":[],"length":0,"stats":{"Line":143}},{"line":202,"address":[],"length":0,"stats":{"Line":133}},{"line":203,"address":[],"length":0,"stats":{"Line":225}},{"line":204,"address":[],"length":0,"stats":{"Line":92}},{"line":205,"address":[],"length":0,"stats":{"Line":92}},{"line":207,"address":[],"length":0,"stats":{"Line":41}},{"line":211,"address":[],"length":0,"stats":{"Line":51}},{"line":212,"address":[],"length":0,"stats":{"Line":51}},{"line":215,"address":[],"length":0,"stats":{"Line":46}},{"line":218,"address":[],"length":0,"stats":{"Line":108}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":291}},{"line":224,"address":[],"length":0,"stats":{"Line":291}},{"line":225,"address":[],"length":0,"stats":{"Line":291}},{"line":228,"address":[],"length":0,"stats":{"Line":43}},{"line":229,"address":[],"length":0,"stats":{"Line":43}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":86}},{"line":232,"address":[],"length":0,"stats":{"Line":86}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":43}},{"line":235,"address":[],"length":0,"stats":{"Line":43}},{"line":237,"address":[],"length":0,"stats":{"Line":43}},{"line":238,"address":[],"length":0,"stats":{"Line":43}},{"line":243,"address":[],"length":0,"stats":{"Line":43}}],"covered":111,"coverable":138},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","tests.rs"],"content":"use crate::frontend::lexer::Lexer;\nuse std::str::Chars;\n\nuse super::token::Token;\n\nfn lexer_from_string(string: \u0026str) -\u003e Lexer\u003cChars\u003e {\n    Lexer::\u003cChars\u003c'_\u003e\u003e::from_iterator(string.chars())\n}\n\n#[test]\nfn peek_none() {\n    let lexer = lexer_from_string(\"a\");\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn advance_char() {\n    let mut lexer = lexer_from_string(\"ab\");\n    assert!(lexer.peek_char() == None);\n    lexer.advance_char();\n    assert!(lexer.peek_char() == Some('a'));\n    lexer.advance_char();\n    assert!(lexer.peek_char() == Some('b'));\n}\n\n#[test]\nfn advance_to_end() {\n    let mut lexer = lexer_from_string(\"a\");\n    lexer.advance_char();\n    lexer.advance_char();\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn test_loc_chars() {\n    let mut lexer = lexer_from_string(\"the quick brown\\nfox jumps\\nover the lazy\\ndog\\n\\n\");\n\n    let mut line_lengths = Vec::new();\n    let mut lines = 0;\n    let mut cols = 0;\n\n    lexer.advance_char();\n    while lexer.peek_char().is_some() {\n        let examined = lexer.peek_char().unwrap();\n        lexer.advance_char();\n        match examined {\n            '\\n' =\u003e {\n                line_lengths.push(cols);\n                cols = 0;\n                lines += 1;\n            }\n            _ =\u003e {\n                cols += 1;\n            }\n        }\n    }\n\n    assert!(lines == 5);\n    assert!(line_lengths == vec![15, 9, 13, 3, 0]);\n}\n\n// helper function - do some basic prefixing and suffixing\n// ensure keyword matching behaves as expected with alpha/num pre/suffixes\nfn kw_or_ident(string: \u0026str, expected_token: Token) {\n    let mut positive_match = lexer_from_string(string);\n    positive_match.advance_char();\n\n    let matched = positive_match.match_kw_or_ident();\n    assert!(matched == expected_token);\n\n    let prefix_alpha = \"a\".to_owned() + string;\n    let mut negative_match = lexer_from_string(\u0026prefix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(prefix_alpha));\n\n    let prefix_num = \"1\".to_owned() + string;\n    negative_match = Lexer::new(prefix_num.chars());\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() != expected_token);\n\n    let suffix_alpha = string.to_owned() + \"a\";\n    negative_match = lexer_from_string(\u0026suffix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(suffix_alpha));\n\n    let suffix_num = string.to_owned() + \"1\";\n    negative_match = lexer_from_string(\u0026suffix_num);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(suffix_num));\n}\n\n// test every token\n#[test]\nfn kw_u8() {\n    kw_or_ident(\"u8\", Token::U8);\n}\n\n#[test]\nfn kw_u16() {\n    kw_or_ident(\"u16\", Token::U16);\n}\n\n#[test]\nfn kw_u32() {\n    kw_or_ident(\"u32\", Token::U32);\n}\n\n#[test]\nfn kw_u64() {\n    kw_or_ident(\"u64\", Token::U64);\n}\n\n#[test]\nfn kw_i8() {\n    kw_or_ident(\"i8\", Token::I8);\n}\n\n#[test]\nfn kw_i16() {\n    kw_or_ident(\"i16\", Token::I16);\n}\n\n#[test]\nfn kw_i32() {\n    kw_or_ident(\"i32\", Token::I32);\n}\n\n#[test]\nfn kw_i64() {\n    kw_or_ident(\"i64\", Token::I64);\n}\n\n#[test]\nfn kw_fun() {\n    kw_or_ident(\"fun\", Token::Fun);\n}\n\n#[test]\nfn kw_if() {\n    kw_or_ident(\"if\", Token::If);\n}\n\n#[test]\nfn kw_else() {\n    kw_or_ident(\"else\", Token::Else);\n}\n\n#[test]\nfn kw_while() {\n    kw_or_ident(\"while\", Token::While);\n}\n\n#[test]\nfn kw_pub() {\n    kw_or_ident(\"pub\", Token::Pub);\n}\n\n#[test]\nfn kw_struct() {\n    kw_or_ident(\"struct\", Token::Struct);\n}\n\n\n#[test]\nfn ident() {\n    // test out some basic identifiers - such as ones containing keywords\n    kw_or_ident(\"foobar\", Token::Identifier(\"foobar\".to_owned()));\n    kw_or_ident(\"the_u8\", Token::Identifier(\"the_u8\".to_owned()));\n    kw_or_ident(\"big_if_true\", Token::Identifier(\"big_if_true\".to_owned()));\n\n    // make sure that we can correctly parse the end of identifiers\n    let space_after = \"space_after abcde\";\n    let space_after_ident = Token::Identifier(String::from(\"space_after\"));\n    let mut positive_match = lexer_from_string(space_after);\n    positive_match.advance_char();\n    assert!(positive_match.match_kw_or_ident() == space_after_ident);\n\n    let prefix_alpha = \"a\".to_owned() + space_after;\n    let mut negative_match = lexer_from_string(\u0026prefix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(String::from(\"aspace_after\")));\n\n    let prefix_num = \"1\".to_owned() + space_after;\n    negative_match = Lexer::new(prefix_num.chars());\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() != space_after_ident);\n\n    let suffix_alpha = space_after.to_owned() + \"a\";\n    negative_match = lexer_from_string(\u0026suffix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == space_after_ident);\n\n    let suffix_num = space_after.to_owned() + \"1\";\n    negative_match = lexer_from_string(\u0026suffix_num);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == space_after_ident);\n}\n\n#[test]\nfn token_display_to_token() {\n    let tokens = vec![\n        Token::U8,\n        Token::U16,\n        Token::U32,\n        Token::U64,\n        Token::I8,\n        Token::I16,\n        Token::I32,\n        Token::I64,\n        Token::Plus,\n        Token::Minus,\n        Token::Star,\n        Token::FSlash,\n        Token::GThan,\n        Token::GThanE,\n        Token::LThan,\n        Token::LThanE,\n        Token::Equals,\n        Token::NotEquals,\n        Token::Assign,\n        Token::Fun,\n        Token::If,\n        Token::Else,\n        Token::While,\n        Token::Pub,\n        Token::Struct,\n        Token::LParen,\n        Token::RParen,\n        Token::Arrow,\n        Token::LCurly,\n        Token::RCurly,\n        Token::Comma,\n        Token::Semicolon,\n        Token::Colon,\n    ];\n\n    for token in tokens {\n        let lex_result = Lexer::new(format!(\"{}\", token).chars()).lex_all();\n        assert!(lex_result.len() == 2);\n        assert!(token == lex_result[0]);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":76}},{"line":7,"address":[],"length":0,"stats":{"Line":76}},{"line":64,"address":[],"length":0,"stats":{"Line":17}},{"line":65,"address":[],"length":0,"stats":{"Line":17}},{"line":66,"address":[],"length":0,"stats":{"Line":17}},{"line":68,"address":[],"length":0,"stats":{"Line":17}},{"line":69,"address":[],"length":0,"stats":{"Line":17}},{"line":71,"address":[],"length":0,"stats":{"Line":17}},{"line":72,"address":[],"length":0,"stats":{"Line":17}},{"line":73,"address":[],"length":0,"stats":{"Line":17}},{"line":74,"address":[],"length":0,"stats":{"Line":17}},{"line":76,"address":[],"length":0,"stats":{"Line":17}},{"line":77,"address":[],"length":0,"stats":{"Line":17}},{"line":78,"address":[],"length":0,"stats":{"Line":17}},{"line":79,"address":[],"length":0,"stats":{"Line":17}},{"line":81,"address":[],"length":0,"stats":{"Line":17}},{"line":82,"address":[],"length":0,"stats":{"Line":17}},{"line":83,"address":[],"length":0,"stats":{"Line":17}},{"line":84,"address":[],"length":0,"stats":{"Line":17}},{"line":86,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":17}},{"line":88,"address":[],"length":0,"stats":{"Line":17}},{"line":89,"address":[],"length":0,"stats":{"Line":17}}],"covered":23,"coverable":23},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","token.rs"],"content":"use std::fmt::Display;\n\n#[derive(Clone, Debug)]\npub enum Token {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Plus,\n    Minus,\n    Star,\n    FSlash,\n    LThan,\n    GThan,\n    LThanE,\n    GThanE,\n    Equals,\n    NotEquals,\n    Assign,\n    Fun,\n    If,\n    Else,\n    Pub,\n    While,\n    Struct,\n    LParen,\n    RParen,\n    Arrow,\n    LCurly,\n    RCurly,\n    Comma,\n    Semicolon,\n    Colon,\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Eof,\n}\n\nimpl PartialEq for Token {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Token::U8, Token::U8) =\u003e true,\n            (Token::U16, Token::U16) =\u003e true,\n            (Token::U32, Token::U32) =\u003e true,\n            (Token::U64, Token::U64) =\u003e true,\n            (Token::I8, Token::I8) =\u003e true,\n            (Token::I16, Token::I16) =\u003e true,\n            (Token::I32, Token::I32) =\u003e true,\n            (Token::I64, Token::I64) =\u003e true,\n            (Token::Plus, Token::Plus) =\u003e true,\n            (Token::Minus, Token::Minus) =\u003e true,\n            (Token::Star, Token::Star) =\u003e true,\n            (Token::FSlash, Token::FSlash) =\u003e true,\n            (Token::LThan, Token::LThan) =\u003e true,\n            (Token::GThan, Token::GThan) =\u003e true,\n            (Token::LThanE, Token::LThanE) =\u003e true,\n            (Token::GThanE, Token::GThanE) =\u003e true,\n            (Token::Equals, Token::Equals) =\u003e true,\n            (Token::NotEquals, Token::NotEquals) =\u003e true,\n            (Token::Assign, Token::Assign) =\u003e true,\n            (Token::Fun, Token::Fun) =\u003e true,\n            (Token::If, Token::If) =\u003e true,\n            (Token::Else, Token::Else) =\u003e true,\n            (Token::While, Token::While) =\u003e true,\n            (Token::Pub, Token::Pub) =\u003e true,\n            (Token::Struct, Token::Struct) =\u003e true,\n            (Token::LParen, Token::LParen) =\u003e true,\n            (Token::RParen, Token::RParen) =\u003e true,\n            (Token::Arrow, Token::Arrow) =\u003e true,\n            (Token::LCurly, Token::LCurly) =\u003e true,\n            (Token::RCurly, Token::RCurly) =\u003e true,\n            (Token::Comma, Token::Comma) =\u003e true,\n            (Token::Semicolon, Token::Semicolon) =\u003e true,\n            (Token::Colon, Token::Colon) =\u003e true,\n            (Token::Identifier(a), Token::Identifier(b)) =\u003e a == b,\n            (Token::UnsignedDecimalConstant(a), Token::UnsignedDecimalConstant(b)) =\u003e a == b,\n            (Token::Eof, Token::Eof) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl Eq for Token {}\n\nimpl Display for Token {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Plus =\u003e write!(f, \"+\"),\n            Self::Minus =\u003e write!(f, \"-\"),\n            Self::Star =\u003e write!(f, \"*\"),\n            Self::FSlash =\u003e write!(f, \"/\"),\n            Self::GThan =\u003e write!(f, \"\u003e\"),\n            Self::GThanE =\u003e write!(f, \"\u003e=\"),\n            Self::LThan =\u003e write!(f, \"\u003c\"),\n            Self::LThanE =\u003e write!(f, \"\u003c=\"),\n            Self::Equals =\u003e write!(f, \"==\"),\n            Self::NotEquals =\u003e write!(f, \"!=\"),\n            Self::Assign =\u003e write!(f, \"=\"),\n            Self::Fun =\u003e write!(f, \"fun\"),\n            Self::If =\u003e write!(f, \"if\"),\n            Self::Else =\u003e write!(f, \"else\"),\n            Self::While =\u003e write!(f, \"while\"),\n            Self::Pub =\u003e write!(f, \"pub\"),\n            Self::Struct =\u003e write!(f, \"struct\"),\n            Self::LParen =\u003e write!(f, \"(\"),\n            Self::RParen =\u003e write!(f, \")\"),\n            Self::Arrow =\u003e write!(f, \"-\u003e\"),\n            Self::LCurly =\u003e write!(f, \"{{\"),\n            Self::RCurly =\u003e write!(f, \"}}\"),\n            Self::Comma =\u003e write!(f, \",\"),\n            Self::Semicolon =\u003e write!(f, \";\"),\n            Self::Colon =\u003e write!(f, \":\"),\n            Self::Identifier(string) =\u003e write!(f, \"Identifier({})\", string),\n            Self::UnsignedDecimalConstant(constant) =\u003e {\n                write!(f, \"UnsignedDecimalConstant({})\", constant)\n            }\n            Self::Eof =\u003e write!(f, \"EOF\"),\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":143}},{"line":45,"address":[],"length":0,"stats":{"Line":143}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":67}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":14}},{"line":90,"address":[],"length":0,"stats":{"Line":43}},{"line":91,"address":[],"length":0,"stats":{"Line":43}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":77,"coverable":78},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","mod.rs"],"content":"pub mod ast;\npub mod lexer;\npub mod parser;\npub mod sourceloc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","parser","mod.rs"],"content":"mod tests;\n\nuse crate::midend::{ir, types::Type};\n\nuse super::{\n    ast::*,\n    lexer::{token::Token, *},\n    sourceloc::SourceLoc,\n};\n\npub struct Parser\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    lexer: Lexer\u003cI\u003e,\n}\n\nimpl ir::BinaryOperations {\n    pub fn get_precedence(\u0026self) -\u003e usize {\n        match self {\n            Self::Add(_) =\u003e 1,\n            Self::Subtract(_) =\u003e 1,\n            Self::Multiply(_) =\u003e 2,\n            Self::Divide(_) =\u003e 2,\n            Self::LThan(_) =\u003e 3,\n            Self::GThan(_) =\u003e 3,\n            Self::LThanE(_) =\u003e 3,\n            Self::GThanE(_) =\u003e 3,\n            Self::Equals(_) =\u003e 4,\n            Self::NotEquals(_) =\u003e 4,\n        }\n    }\n\n    pub fn precedence_of_token(token: \u0026Token) -\u003e usize {\n        match token {\n            Token::Plus =\u003e 1,\n            Token::Minus =\u003e 1,\n            Token::Star =\u003e 2,\n            Token::FSlash =\u003e 2,\n            Token::LThan =\u003e 3,\n            Token::GThan =\u003e 3,\n            Token::LThanE =\u003e 3,\n            Token::GThanE =\u003e 3,\n            Token::Equals =\u003e 4,\n            Token::NotEquals =\u003e 4,\n            _ =\u003e {\n                panic!(\n                    \"Invalid token {} passed to BinaryOperations::precedence_of_token\",\n                    token\n                );\n            }\n        }\n    }\n}\n\nimpl\u003cI\u003e Parser\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    pub fn new(lexer: Lexer\u003cI\u003e) -\u003e Self\n    where\n        I: Iterator\u003cItem = char\u003e,\n    {\n        Parser { lexer: lexer }\n    }\n\n    fn peek_token(\u0026self) -\u003e Token {\n        return self.lexer.peek();\n    }\n\n    fn next_token(\u0026mut self) -\u003e Token {\n        return self.lexer.next();\n    }\n\n    fn expect_token(\u0026mut self, t: Token) -\u003e Token {\n        if matches!(self.peek_token(), t) {\n            self.next_token()\n        } else {\n            panic!(\n                \"Expected token {} at {}, got token {} instead!\",\n                t,\n                self.lexer.current_loc(),\n                self.peek_token()\n            );\n        }\n    }\n\n    fn current_loc(\u0026self) -\u003e SourceLoc {\n        self.lexer.current_loc()\n    }\n\n    fn unexpected_token\u003cT\u003e(\u0026self) -\u003e T {\n        panic!(\n            \"Unexpected token {} at {}\",\n            self.peek_token(),\n            self.current_loc()\n        );\n    }\n\n    pub fn parse(\u0026mut self) -\u003e Vec\u003cTranslationUnitTree\u003e {\n        let mut translation_units = Vec::new();\n        while self.lexer.peek() != Token::Eof {\n            translation_units.push(self.parse_translation_unit());\n        }\n        translation_units\n    }\n\n    fn parse_translation_unit(\u0026mut self) -\u003e TranslationUnitTree {\n        match self.peek_token() {\n            Token::Fun =\u003e self.parse_function_declaration_or_definition(),\n            _ =\u003e self.unexpected_token::\u003cTranslationUnitTree\u003e(),\n        }\n    }\n\n    fn parse_function_declaration_or_definition(\u0026mut self) -\u003e TranslationUnitTree {\n        let function_declaration = self.parse_function_prototype();\n        match self.peek_token() {\n            Token::LCurly =\u003e TranslationUnitTree {\n                loc: function_declaration.loc,\n                contents: TranslationUnit::FunctionDefinition(FunctionDefinitionTree {\n                    prototype: function_declaration,\n                    body: self.parse_compound_statement(),\n                }),\n            },\n            _ =\u003e TranslationUnitTree {\n                loc: function_declaration.loc,\n                contents: TranslationUnit::FunctionDeclaration(function_declaration),\n            },\n        }\n    }\n\n    fn parse_compound_statement(\u0026mut self) -\u003e CompoundStatementTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::LCurly);\n        let mut statements: Vec\u003cStatementTree\u003e = Vec::new();\n        loop {\n            match self.peek_token() {\n                Token::RCurly =\u003e break,\n                _ =\u003e statements.push(self.parse_statement()),\n            }\n        }\n        self.expect_token(Token::RCurly);\n        CompoundStatementTree {\n            loc: start_loc,\n            statements: statements,\n        }\n    }\n\n    fn parse_statement(\u0026mut self) -\u003e StatementTree {\n        let statement_tree = StatementTree {\n            loc: self.current_loc(),\n            statement: match self.peek_token() {\n                Token::Identifier(identifier) =\u003e {\n                    self.next_token();\n                    let statement = match self.peek_token() {\n                        Token::Colon =\u003e Statement::VariableDeclaration(\n                            self.parse_variable_declaration(identifier),\n                        ),\n                        Token::Assign =\u003e Statement::Assignment(self.parse_assignment(identifier)),\n                        _ =\u003e self.unexpected_token(),\n                    };\n                    self.expect_token(Token::Semicolon);\n                    statement\n                }\n                Token::If =\u003e Statement::IfStatement(self.parse_if_statement()),\n                Token::While =\u003e Statement::WhileLoop(self.parse_while_loop()),\n                _ =\u003e self.unexpected_token(),\n            },\n        };\n        statement_tree\n    }\n\n    fn parse_if_statement(\u0026mut self) -\u003e IfStatementTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::If);\n\n        self.expect_token(Token::LParen);\n        let condition: ExpressionTree = self.parse_expression();\n        self.expect_token(Token::RParen);\n\n        let true_block = self.parse_compound_statement();\n        let false_block = match self.peek_token() {\n            Token::Else =\u003e {\n                self.expect_token(Token::Else);\n                Some(self.parse_compound_statement())\n            }\n            _ =\u003e None,\n        };\n\n        IfStatementTree {\n            loc: start_loc,\n            condition,\n            true_block,\n            false_block,\n        }\n    }\n\n    fn parse_while_loop(\u0026mut self) -\u003e WhileLoopTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::While);\n\n        self.expect_token(Token::LParen);\n        let condition = self.parse_expression();\n        self.expect_token(Token::RParen);\n\n        let body = self.parse_compound_statement();\n\n        WhileLoopTree {\n            loc: start_loc,\n            condition,\n            body,\n        }\n    }\n\n    fn parse_assignment(\u0026mut self, identifier: String) -\u003e AssignmentTree {\n        let start_loc = self.current_loc();\n        let lhs = identifier;\n        self.expect_token(Token::Assign);\n        AssignmentTree {\n            loc: start_loc,\n            identifier: lhs,\n            value: self.parse_expression(),\n        }\n    }\n\n    fn parse_primary_expression(\u0026mut self) -\u003e ExpressionTree {\n        ExpressionTree {\n            loc: self.current_loc(),\n            expression: {\n                let primary_expression = match self.peek_token() {\n                    Token::Identifier(value) =\u003e {\n                        self.next_token();\n                        Expression::Identifier(value)\n                    }\n                    Token::UnsignedDecimalConstant(value) =\u003e {\n                        self.next_token();\n                        Expression::UnsignedDecimalConstant(value)\n                    }\n                    Token::LParen =\u003e {\n                        self.expect_token(Token::LParen);\n                        let expr = self.parse_expression();\n                        self.expect_token(Token::RParen);\n                        expr.expression\n                    } // TODO: don't duplciate ExpressionTree here\n                    _ =\u003e self.unexpected_token(),\n                };\n                primary_expression\n            },\n        }\n    }\n\n    fn token_is_operator_of_at_least_precedence(token: \u0026Token, precedence: usize) -\u003e bool {\n        match token {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e ir::BinaryOperations::precedence_of_token(\u0026token) \u003e= precedence,\n            _ =\u003e false,\n        }\n    }\n\n    fn parse_expression_min_precedence(\n        \u0026mut self,\n        lhs: ExpressionTree,\n        min_precedence: usize,\n    ) -\u003e ExpressionTree {\n        let mut expr = lhs;\n        let start_loc = self.current_loc();\n        while Self::token_is_operator_of_at_least_precedence(\u0026self.peek_token(), min_precedence) {\n            let operation = self.next_token();\n            let mut rhs = self.parse_primary_expression();\n\n            while Self::token_is_operator_of_at_least_precedence(\n                \u0026self.peek_token(),\n                ir::BinaryOperations::precedence_of_token(\u0026operation),\n            ) {\n                rhs = self.parse_expression_min_precedence(\n                    rhs,\n                    ir::BinaryOperations::precedence_of_token(\u0026operation),\n                );\n            }\n\n            let operands = ArithmeticDualOperands {\n                e1: Box::new(expr),\n                e2: Box::new(rhs),\n            };\n            expr = ExpressionTree {\n                loc: start_loc,\n                expression: match operation {\n                    Token::Plus =\u003e Expression::Arithmetic(ArithmeticOperationTree::Add(operands)),\n                    Token::Minus =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Subtract(operands))\n                    }\n                    Token::Star =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Multiply(operands))\n                    }\n                    Token::FSlash =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Divide(operands))\n                    }\n                    Token::LThan =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::LThan(operands))\n                    }\n                    Token::GThan =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::GThan(operands))\n                    }\n                    Token::LThanE =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::LThanE(operands))\n                    }\n                    Token::GThanE =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::GThanE(operands))\n                    }\n                    Token::Equals =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::Equals(operands))\n                    }\n                    Token::NotEquals =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::NotEquals(operands))\n                    }\n                    _ =\u003e self.unexpected_token(),\n                },\n            };\n        }\n        expr\n    }\n\n    fn parse_expression(\u0026mut self) -\u003e ExpressionTree {\n        let lhs = self.parse_primary_expression();\n        match self.peek_token() {\n            Token::Plus | Token::Minus | Token::Star | Token::FSlash =\u003e {\n                self.parse_expression_min_precedence(lhs, 0)\n            }\n            Token::GThan\n            | Token::GThanE\n            | Token::LThan\n            | Token::LThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e self.parse_expression_min_precedence(lhs, 0),\n            _ =\u003e lhs,\n        }\n    }\n\n    fn parse_function_prototype(\u0026mut self) -\u003e FunctionDeclarationTree {\n        let start_loc = self.current_loc();\n        // start with fun\n        self.expect_token(Token::Fun);\n        FunctionDeclarationTree {\n            // grab start location and name\n            loc: start_loc,\n            name: self.parse_identifier(),\n            arguments: {\n                self.expect_token(Token::LParen);\n                let mut arguments = Vec::\u003cVariableDeclarationTree\u003e::new();\n                loop {\n                    match self.peek_token() {\n                        // argument declaration\n                        Token::Identifier(identifier) =\u003e {\n                            self.next_token();\n                            arguments.push(self.parse_variable_declaration(identifier));\n                            match self.peek_token() {\n                                Token::Comma =\u003e self.next_token(), // expect another argument declaration after comma\n                                _ =\u003e break,                        // loop again for anything else\n                            };\n                        }\n                        Token::RParen =\u003e break, // done on rparen\n                        _ =\u003e self.unexpected_token(),\n                    }\n                }\n                // consume closing paren\n                self.expect_token(Token::RParen);\n                arguments\n            },\n            return_type: match self.peek_token() {\n                Token::Arrow =\u003e {\n                    self.next_token();\n                    Some(self.parse_typename())\n                }\n                _ =\u003e None,\n            },\n        }\n    }\n\n    fn parse_variable_declaration(\u0026mut self, name: String) -\u003e VariableDeclarationTree {\n        VariableDeclarationTree {\n            loc: self.current_loc(),\n            name,\n            typename: {\n                self.expect_token(Token::Colon);\n                self.parse_typename()\n            },\n        }\n    }\n\n    fn parse_typename(\u0026mut self) -\u003e TypenameTree {\n        TypenameTree {\n            loc: self.current_loc(),\n            type_: match self.peek_token() {\n                Token::U8 =\u003e {\n                    self.next_token();\n                    Type::U8\n                }\n                Token::U16 =\u003e {\n                    self.next_token();\n                    Type::U16\n                }\n                Token::U32 =\u003e {\n                    self.next_token();\n                    Type::U32\n                }\n                Token::U64 =\u003e {\n                    self.next_token();\n                    Type::U64\n                }\n                Token::I8 =\u003e {\n                    self.next_token();\n                    Type::I8\n                }\n                Token::I16 =\u003e {\n                    self.next_token();\n                    Type::I16\n                }\n                Token::I32 =\u003e {\n                    self.next_token();\n                    Type::I32\n                }\n                Token::I64 =\u003e {\n                    self.next_token();\n                    Type::I64\n                }\n                _ =\u003e self.unexpected_token(),\n            },\n        }\n    }\n\n    fn parse_identifier(\u0026mut self) -\u003e String {\n        match self.expect_token(Token::Identifier(String::from(\"\"))) {\n            Token::Identifier(value) =\u003e value,\n            _ =\u003e self.unexpected_token::\u003cString\u003e(),\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":78}},{"line":35,"address":[],"length":0,"stats":{"Line":78}},{"line":36,"address":[],"length":0,"stats":{"Line":40}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":13}},{"line":67,"address":[],"length":0,"stats":{"Line":238}},{"line":68,"address":[],"length":0,"stats":{"Line":238}},{"line":71,"address":[],"length":0,"stats":{"Line":131}},{"line":72,"address":[],"length":0,"stats":{"Line":131}},{"line":75,"address":[],"length":0,"stats":{"Line":52}},{"line":76,"address":[],"length":0,"stats":{"Line":52}},{"line":77,"address":[],"length":0,"stats":{"Line":52}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":97}},{"line":89,"address":[],"length":0,"stats":{"Line":97}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":9}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":5}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":226,"address":[],"length":0,"stats":{"Line":51}},{"line":228,"address":[],"length":0,"stats":{"Line":51}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":90}},{"line":253,"address":[],"length":0,"stats":{"Line":90}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":36}},{"line":264,"address":[],"length":0,"stats":{"Line":54}},{"line":268,"address":[],"length":0,"stats":{"Line":27}},{"line":273,"address":[],"length":0,"stats":{"Line":27}},{"line":274,"address":[],"length":0,"stats":{"Line":27}},{"line":275,"address":[],"length":0,"stats":{"Line":55}},{"line":276,"address":[],"length":0,"stats":{"Line":28}},{"line":277,"address":[],"length":0,"stats":{"Line":28}},{"line":279,"address":[],"length":0,"stats":{"Line":35}},{"line":280,"address":[],"length":0,"stats":{"Line":35}},{"line":281,"address":[],"length":0,"stats":{"Line":35}},{"line":283,"address":[],"length":0,"stats":{"Line":7}},{"line":284,"address":[],"length":0,"stats":{"Line":7}},{"line":285,"address":[],"length":0,"stats":{"Line":7}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":28}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":14}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":27}},{"line":331,"address":[],"length":0,"stats":{"Line":23}},{"line":332,"address":[],"length":0,"stats":{"Line":23}},{"line":333,"address":[],"length":0,"stats":{"Line":23}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":17}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":0}}],"covered":92,"coverable":182},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","parser","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::frontend::lexer::{token::Token, *};\n    use crate::Parser;\n    use std::str::Chars;\n\n    #[cfg(test)]\n    fn parser_from_string(input: \u0026str) -\u003e Parser\u003cChars\u003c'_\u003e\u003e {\n        Parser::new(Lexer::new(input.chars()))\n    }\n\n    /// Expressions\n    #[cfg(test)]\n    fn parse_and_print_expression(input: \u0026str) -\u003e String {\n        let mut parser = parser_from_string(input);\n        let expr_string = parser.parse_expression().to_string();\n        parser.expect_token(Token::Eof);\n        expr_string\n    }\n\n    #[test]\n    fn basic_expression() {\n        assert_eq!(\n            parse_and_print_expression(\"123 + 456 + 789\"),\n            \"(123 + (456 + 789))\"\n        );\n    }\n\n    #[test]\n    fn addition_and_multiplication() {\n        assert_eq!(\n            parse_and_print_expression(\"123 + 456 * 789\"),\n            \"(123 + (456 * 789))\"\n        );\n    }\n\n    #[test]\n    fn parentheses_override_precedence() {\n        assert_eq!(\n            parse_and_print_expression(\"(123 + 456) * 789\"),\n            \"((123 + 456) * 789)\"\n        );\n    }\n\n    #[test]\n    fn mixed_arithmetic_operations() {\n        assert_eq!(\n            parse_and_print_expression(\"1 + 2 * 3 - 4 / 5\"),\n            \"(1 + ((2 * 3) - (4 / 5)))\"\n        );\n    }\n\n    #[test]\n    fn nested_parentheses() {\n        assert_eq!(\n            parse_and_print_expression(\"((1 + 2) * (3 - 4)) / 5\"),\n            \"(((1 + 2) * (3 - 4)) / 5)\"\n        );\n    }\n\n    #[test]\n    fn single_number() {\n        assert_eq!(parse_and_print_expression(\"42\"), \"42\");\n    }\n\n    #[test]\n    fn single_number_parenthesized() {\n        assert_eq!(parse_and_print_expression(\"(42)\"), \"42\");\n    }\n\n    #[test]\n    fn multiple_additions() {\n        assert_eq!(parse_and_print_expression(\"1 + 2 + 3\"), \"(1 + (2 + 3))\");\n    }\n\n    #[test]\n    fn complex_arithmetic_expression() {\n        assert_eq!(\n            parse_and_print_expression(\"3 + 4 * 2 / (1 - 5)\"),\n            \"(3 + (4 * (2 / (1 - 5))))\"\n        );\n    }\n\n    /// variable declarations\n    fn parse_and_print_variable_declaration(input: \u0026str) -\u003e String {\n        let mut parser = parser_from_string(input);\n        let ident = parser.parse_identifier();\n        let expr_string = parser.parse_variable_declaration(ident).to_string();\n        parser.expect_token(Token::Eof);\n        expr_string\n    }\n\n    #[test]\n    fn u8_declaration() {\n        assert_eq!(parse_and_print_variable_declaration(\"abc: u8\"), \"abc: u8\");\n    }\n\n    #[test]\n    fn if_statement() {\n        let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;}\");\n        assert_eq!(\n            format!(\"{}\", p.parse_if_statement()),\n            \"if (a \u003e b)\n\\t{Compound Statement: a = (a + b)\n}\"\n        );\n    }\n\n    #[test]\n    fn if_else_statement() {\n        let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;} else {b = b + a;}\");\n        assert_eq!(\n            format!(\"{}\", p.parse_if_statement()),\n            \"if (a \u003e b)\n\\t{Compound Statement: a = (a + b)\n} else {Compound Statement: b = (b + a)\n}\"\n        );\n    }\n    // assert_eq!(p.parse_if_statement(), IfStatementTree {loc: SouceLoc::new(0, 0),\n    // condition: Expression {loc: SourceLoc::new(0, 5), expression: Expression::Comparison(ComparisonOperationTree::GThan(ArithmeticDualOperands {Box::new(ExpressionTree {loc: SourceLoc::new()})}))}});}}\n\n    #[test]\n    fn while_loop() {\n        let mut p =\n            parser_from_string(\"while (a \u003e b) {b = b + a; count = count + 1;} a = a + count;\");\n        assert_eq!(\n            format!(\"{}\", p.parse_while_loop()),\n            \"while ((a \u003e b)) Compound Statement: b = (b + a)\ncount = (count + 1)\n\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","sourceloc.rs"],"content":"use std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct SourceLoc {\n    line: usize,\n    col: usize,\n}\n\nimpl SourceLoc {\n    pub fn none() -\u003e Self {\n        SourceLoc { line: 0, col: 0 }\n    }\n\n    pub fn new(line: usize, col: usize) -\u003e Self {\n        SourceLoc { line, col }\n    }\n}\n\nimpl Display for SourceLoc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.col)\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":14}},{"line":16,"address":[],"length":0,"stats":{"Line":119}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","Users","mitch","substratum","rust-rewrite","src","hashmap_ooo_iter.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::hash::Hash;\n\nfn check_key_order\u003cK, V\u003e(map: \u0026HashMap\u003cK, V\u003e, key_order: \u0026Vec\u003cK\u003e)\nwhere\n    K: Eq + Hash,\n{\n    let mut seen_keys = HashSet::\u003c\u0026K\u003e::new();\n    for key in key_order {\n        assert!(\n            map.contains_key(key),\n            \"All keys in key ordering for out-of-order HashMap iterator must be present in map\"\n        );\n        assert!(\n            !seen_keys.contains(key),\n            \"Duplicate key seen in key ordering for out-of-order HashMap iterator\",\n        );\n        seen_keys.insert(key);\n    }\n\n    assert!(\n        seen_keys.len() == map.len(),\n        \"Missing key(s) from key ordering for out-of-order HashMap iterator. All keys must be included\"\n    );\n}\n\n// the iterator itself only needs to own Key, \u0026Value pairs\npub struct HashMapOOOIter\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a V)\u003e,\n}\n\n// iteration is simply popping from the references vec\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIter\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIter\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // allocate the vector with its full capacity from the get-go\n        let mut references = Vec::\u003c(K, \u0026'a V)\u003e::with_capacity(map.len());\n        // grab values for each key, moving each key into the references vector along with its corresponding value reference\n        for key in key_order.into_iter().rev() {\n            let value_ref: \u0026V = map.get(\u0026key).unwrap();\n            references.push((key, value_ref));\n        }\n\n        HashMapOOOIter { references }\n    }\n}\n\npub struct HashMapOOOIterMut\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a mut V)\u003e,\n}\n\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIterMut\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a mut V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIterMut\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a mut HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // same as for HashMapOOOIter but with additional reference manipulation\n        let mut references = Vec::\u003c(K, \u0026'a mut V)\u003e::with_capacity(map.len());\n        for key in key_order.into_iter().rev() {\n            // get our value reference as normal\n            let value: \u0026V = map.get(\u0026key).unwrap();\n            // create a pointer from the reference, and cast it to a mutable pointer\n            let pointer: *const V = std::ptr::from_ref(value);\n            let mut_pointer: *mut V = pointer as *mut V;\n            // since we have exactly one instance of every key in the map per check_key_order()\n            let value_mut: \u0026mut V = unsafe {\n                // trust that we can .as_mut() the pointer into a mutable reference\n                mut_pointer.as_mut()\n            }\n            .unwrap();\n            references.push((key, value_mut));\n        }\n\n        HashMapOOOIterMut { references }\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","mitch","substratum","rust-rewrite","src","main.rs"],"content":"mod backend;\nmod frontend;\nmod midend;\n\nmod hashmap_ooo_iter;\n\nuse backend::generate_code;\nuse frontend::{lexer::Lexer, parser::Parser};\n\nconst FIB_FUN: \u0026str = \"fun fib(u8 n) -\u003e u64\n{\n    u64 result;\n    result = 0;\n    if (n \u003e 0) {\n        if(n == 0) {\n            result = 0;\n        } else {\n         result = 1;\n        }\n    } else {\n        result = (n - 1) - (n - 2);\n    }\n}\";\n\nconst WHILE_LOOP: \u0026str = \"fun down_to_zero(u16 input)\n{\n    input = input;\n    while(input \u003e 0) {\n        input = input - 1;\n    }\n\n    input = input + 1;\n}\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH: \u0026str = \"\nfun while_with_nested_branch(a: u8, b: u16, c: u32) {\n    counter: u8;\n    counter = 0;\n    while (a \u003c b) {\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            counter = counter - 1;\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH_NO_ARGS: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    while (a \u003c b) {\n        u8 counter;\n        if (c \u003e 22) {\n            a = a + b;\n        } else {\n            b = b - 1;\n        }\n    }\n}\n\";\n\nconst NESTED_WHILE_LOOPS: \u0026str = \"\nfun while_with_nested_branch(u8 a, u16 b, u32 c) {\n    while (a \u003c b) {\n        u8 counter;\n        counter = 0;\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            while (counter \u003e 0) {\n            counter = counter - 1;\n            }\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst SSA_EXAMPLE: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    \n    a = b + c;\n    b = a + c;\n    if (a \u003e b) {\n    c = c + 1;\n    } else {\n     c = 1;}\n    c = c + 1;\n    c = c + 1;\n}\";\n\nfn main() {\n    println!(\"Hello, world!\");\n    let parsed = String::from(WHILE_LOOP_WITH_NESTED_BRANCH);\n    let mut parser = Parser::new(Lexer::new(parsed.chars()));\n    let program = parser.parse();\n\n    for t in \u0026program {\n        println!(\"{}\", t);\n    }\n\n    let mut symtab = midend::symbol_table_from_program(program);\n\n    // println!(\"{}\", serde_json::to_string_pretty(\u0026symtab).unwrap());\n    symtab.print_ir();\n\n    symtab.assign_program_points();\n\n    generate_code(symtab);\n}\n","traces":[{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","block_args.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct BlockArgs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for BlockArgs\u003c'a\u003e {\n    fn f_transfer(\n        facts: \u0026mut idfa_base::BlockFacts\u003cFact\u003e,\n        _to_transfer: BTreeSet\u003cFact\u003e,\n    ) -\u003e BTreeSet\u003cFact\u003e {\n        facts.gen_facts.clone()\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut super::Facts\u003cFact\u003e) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    if !block_facts.kill_facts.contains(read) {\n                        block_facts.gen_facts.insert(read.clone());\n                    }\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.kill_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(mut a: BTreeSet\u003cFact\u003e, b: \u0026BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e super::Facts\u003cFact\u003e {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","block_depths.rs"],"content":"\npub struct BlockDepths\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","idfa_base.rs"],"content":"use std::{\n    collections::{BTreeSet, HashMap},\n    fmt::Display,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\npub enum IdfaAnalysisDirection {\n    Forward,\n    Backward,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BlockFacts\u003cT\u003e {\n    pub in_facts: BTreeSet\u003cT\u003e,\n    pub out_facts: BTreeSet\u003cT\u003e,\n    pub gen_facts: BTreeSet\u003cT\u003e,\n    pub kill_facts: BTreeSet\u003cT\u003e,\n}\n\nimpl\u003cT\u003e BlockFacts\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        BlockFacts {\n            in_facts: BTreeSet::\u003cT\u003e::new(),\n            out_facts: BTreeSet::\u003cT\u003e::new(),\n            gen_facts: BTreeSet::\u003cT\u003e::new(),\n            kill_facts: BTreeSet::\u003cT\u003e::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    facts: HashMap\u003cusize, BlockFacts\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub fn new(n_blocks: usize) -\u003e Self {\n        Self {\n            facts: HashMap::new(),\n        }\n    }\n    pub fn for_label(\u0026self, label: usize) -\u003e \u0026BlockFacts\u003cT\u003e {\n        self.facts.get(\u0026label).unwrap()\n    }\n\n    pub fn for_label_mut(\u0026mut self, label: usize) -\u003e \u0026mut BlockFacts\u003cT\u003e {\n        self.facts.entry(label).or_insert(BlockFacts::\u003cT\u003e::new())\n    }\n}\n\npub trait IdfaImplementor\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    fn f_transfer(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e);\n    fn f_meet(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self;\n    fn reanalyze(\u0026mut self);\n    fn take_facts(self) -\u003e Facts\u003cT\u003e;\n    fn facts(\u0026self) -\u003e \u0026Facts\u003cT\u003e;\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts\u003cT\u003e;\n}\n\n#[derive(Debug)]\npub struct Idfa\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub control_flow: \u0026'a ir::ControlFlow,\n    direction: IdfaAnalysisDirection,\n    last_facts: Facts\u003cT\u003e,\n    pub facts: Facts\u003cT\u003e,\n    f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n    f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n}\n\nimpl\u003c'a, T\u003e Idfa\u003c'a, T\u003e\nwhere\n    Facts\u003cT\u003e: PartialEq,\n    T: std::fmt::Debug + Display + Clone + Ord,\n{\n    fn store_facts_as_last(\u0026mut self) {\n        self.last_facts = self.facts.clone();\n    }\n\n    fn reached_fixpoint(\u0026mut self) -\u003e bool {\n        self.facts == self.last_facts\n    }\n\n    fn analyze_block_forwards\u003c'b\u003e(\u0026mut self, block: \u0026ir::BasicBlock) {\n        let label = block.label;\n        let mut new_in_facts = BTreeSet::\u003cT\u003e::new();\n\n        for predecessor in \u0026block.predecessors {\n            new_in_facts =\n                (self.f_meet)(new_in_facts, \u0026self.facts.for_label(*predecessor).out_facts);\n        }\n\n        self.facts.for_label_mut(label).in_facts = new_in_facts.clone();\n        let transferred = (self.f_transfer)(self.facts.for_label_mut(label), new_in_facts);\n        self.facts.for_label_mut(label).out_facts = transferred;\n    }\n\n    fn analyze_forward(\u0026mut self) {\n        let mut first_iteration = true;\n        while !self.reached_fixpoint() || first_iteration {\n            first_iteration = false;\n            self.store_facts_as_last();\n\n            for (_, block) in \u0026self.control_flow.blocks {\n                self.analyze_block_forwards(block);\n            }\n        }\n    }\n\n    fn analyze_backward(\u0026mut self) {\n        // let mut first_iteration = true;\n        // while !self.reached_fixpoint() || first_iteration {\n        unimplemented!();\n        // first_iteration = false;\n        // self.store_facts_as_last();\n        // }\n    }\n\n    pub fn analyze(\u0026mut self) {\n        (self.f_find_gen_kills)(self.control_flow, \u0026mut self.facts);\n        match self.direction {\n            IdfaAnalysisDirection::Forward =\u003e {\n                self.analyze_forward();\n            }\n            IdfaAnalysisDirection::Backward =\u003e {\n                self.analyze_backward();\n            }\n        }\n    }\n\n    pub fn new(\n        control_flow: \u0026'a ir::ControlFlow,\n        direction: IdfaAnalysisDirection,\n        f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n        f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n        f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    ) -\u003e Self {\n        let mut idfa = Self {\n            control_flow,\n            direction,\n            last_facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            f_find_gen_kills,\n            f_meet,\n            f_transfer,\n        };\n\n        idfa.analyze();\n\n        idfa\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","live_vars.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base::{self, IdfaImplementor};\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct LiveVars\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for LiveVars\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = facts.gen_facts.clone();\n\n        for fact in \u0026to_transfer {\n            if !facts.kill_facts.contains(fact) {\n                transferred.insert(fact.clone());\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","mod.rs"],"content":"pub mod block_args;\nmod idfa_base;\npub mod live_vars;\npub mod reaching_defs;\n\npub use block_args::BlockArgs;\npub use idfa_base::Facts;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","reaching_defs.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct ReachingDefs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for ReachingDefs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = BTreeSet::\u003cFact\u003e::new();\n\n        for gen_fact in \u0026facts.gen_facts {\n            if !facts.kill_facts.contains(gen_fact) {\n                transferred.insert(gen_fact.clone());\n            }\n        }\n\n        for in_fact in \u0026facts.in_facts {\n            if !facts.kill_facts.contains(in_fact) {\n                transferred.insert(in_fact.clone());\n            }\n        }\n\n        for transfer_fact in to_transfer {\n            if !facts.kill_facts.contains(\u0026transfer_fact) {\n                transferred.insert(transfer_fact);\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        //TODO: need to be able to possibly act on function arguments for gen/kill\n        // e.g. reaching defs on function arguments\n\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n\nimpl\u003c'a\u003e ReachingDefs\u003c'a\u003e\n// TODO: supertrait?\n{\n    pub fn print(\u0026self) {\n        for label in self.idfa.control_flow.blocks.keys() {\n            let facts = self.idfa.facts.for_label(*label);\n            println!(\"{}:\", label);\n\n            print!(\"\\tGEN:\");\n            for gen_fact in \u0026facts.gen_facts {\n                print!(\"{} \", gen_fact);\n            }\n            println!();\n\n            print!(\"\\tKILL:\");\n            for kill_fact in \u0026facts.kill_facts {\n                print!(\"{} \", kill_fact);\n            }\n            println!();\n\n            print!(\"\\tIN:\");\n            for in_fact in \u0026facts.in_facts {\n                print!(\"{} \", in_fact);\n            }\n            println!();\n\n            print!(\"\\tOUT:\");\n            for out_fact in \u0026facts.out_facts {\n                print!(\"{} \", out_fact);\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","control_flow.rs"],"content":"use crate::{\n    frontend::sourceloc::SourceLoc,\n    hashmap_ooo_iter::{HashMapOOOIter, HashMapOOOIterMut},\n};\n\nuse super::ir;\nuse serde::Serialize;\nuse std::{\n    collections::{HashMap, HashSet, VecDeque},\n    fmt::Debug,\n    usize,\n};\n\n/*\n    A ControlFlow represents the notion of ownership over basic blocks. At the end of linearization of a section of code,\n    all relevant basic blocks will be owned by a single control flow. During linearization control flows can branch\n    correspondingly with actual branches in the code, as they are linarized. Each branch gets its own control flow,\n    which owns only the blocks relevant to the contents of branch. When the linearization of each branch is complete,\n    its control flow is merged back to the one from which it was branched. The original brancher then takes ownership\n    of all blocks of the branchee.\n*/\n\n#[derive(Debug, Serialize)]\npub struct ControlFlow {\n    pub blocks: HashMap\u003cusize, ir::BasicBlock\u003e,\n    pub max_block: usize,\n}\n\nimpl ControlFlow {\n    pub fn new() -\u003e Self {\n        let mut starter_blocks = HashMap::\u003cusize, ir::BasicBlock\u003e::new();\n        starter_blocks.insert(0, ir::BasicBlock::new(0));\n        starter_blocks.insert(1, ir::BasicBlock::new(1));\n        ControlFlow {\n            blocks: starter_blocks,\n            max_block: 1,\n        }\n    }\n\n    pub fn block_for_label(\u0026self, label: \u0026usize) -\u003e \u0026ir::BasicBlock {\n        self.blocks.get(label).unwrap()\n    }\n\n    fn block_mut_for_label(\u0026mut self, label: usize) -\u003e \u0026mut ir::BasicBlock {\n        self.blocks\n            .entry(label)\n            .or_insert(ir::BasicBlock::new(label))\n    }\n\n    pub fn next_block(\u0026mut self) -\u003e usize {\n        self.max_block += 1;\n        self.max_block\n    }\n\n    // appends the given statement to the block with the label provided\n    // returns: (Option\u003cusize\u003e, Option\u003cusize\u003e) referring to (if the statement is a branch):\n    // block targeted by branch\n    // block control flow ends up in if the branch is not taken (conditional branches only)\n    // retrurns an option to a reference to the field containing the destination label of the false jump\n    // iff the statement was a conditional jump which forced the end of the block\n    pub fn append_statement_to_block(\n        \u0026mut self,\n        statement: ir::IrLine,\n        label: usize,\n    ) -\u003e (Option\u003cusize\u003e, Option\u003cusize\u003e) {\n        self.append_statement_to_block_raw(statement.clone(), label);\n\n        match \u0026statement.operation {\n            ir::Operations::Jump(jump) =\u003e {\n                let target = jump.destination_block;\n                match \u0026jump.condition {\n                    ir::JumpCondition::Unconditional =\u003e (Some(target), None),\n                    _ =\u003e {\n                        let false_label = self.next_block();\n                        let block_exit = ir::IrLine::new_jump(\n                            SourceLoc::none(),\n                            false_label,\n                            ir::JumpCondition::Unconditional,\n                        );\n                        self.append_statement_to_block_raw(block_exit, label);\n                        (Some(target), Some(false_label))\n                    }\n                }\n            }\n            _ =\u003e (None, None),\n        }\n    }\n\n    fn append_statement_to_block_raw(\u0026mut self, statement: ir::IrLine, label: usize) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(operands) =\u003e {\n                let target_block = operands.destination_block;\n\n                self.block_mut_for_label(target_block)\n                    .predecessors\n                    .insert(label);\n                self.block_mut_for_label(label)\n                    .successors\n                    .insert(target_block);\n            }\n            _ =\u003e {}\n        };\n\n        self.block_mut_for_label(label).statements.push(statement);\n    }\n\n    pub fn to_graphviz(\u0026self) {\n        print!(\"digraph {{fontname=\\\"consolas\\\"; node[shape=box; fontname=\\\"consolas\\\"; nojustify=true]; splines=ortho;\");\n        for block in self.blocks.values() {\n            let mut block_arg_string = String::new();\n            for arg in \u0026block.arguments {\n                block_arg_string += \u0026format!(\"{} \", arg);\n            }\n\n            let mut block_string =\n                String::from(format!(\"Block {}({})\\n\", block.label, block_arg_string));\n            for statement in \u0026block.statements {\n                let stmt_str = \u0026String::from(format!(\"{}\\\\l\", statement)).replace(\"\\\"\", \"\\\\\\\"\");\n                block_string += stmt_str;\n            }\n\n            println!(\"{}[label=\\\"{}\\\\l\\\"]; \", block.label, block_string);\n\n            for successor in \u0026block.successors {\n                print!(\"{}-\u003e{};\", block.label, successor);\n            }\n        }\n\n        println!(\"}}\");\n    }\n\n    pub fn replace_blocks\u003cT: IntoIterator\u003cItem = ir::BasicBlock\u003e\u003e(\u0026mut self, iter: T) {\n        let mut into = iter.into_iter();\n\n        while let Some(block) = into.next() {\n            self.max_block = usize::max(self.max_block, block.label);\n            self.blocks.insert(block.label, block);\n        }\n    }\n}\n\nstruct ControlFlowPostorder {\n    postorder_stack: VecDeque\u003cir::BasicBlock\u003e,\n}\n\nimpl Iterator for ControlFlowPostorder {\n    type Item = ir::BasicBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_front()\n    }\n}\n\nstruct ControlFlowIter\u003c'a\u003e {\n    postorder_stack: VecDeque\u003c\u0026'a ir::BasicBlock\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for ControlFlowIter\u003c'a\u003e {\n    type Item = \u0026'a ir::BasicBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\npub struct ControlFlowIntoIter\u003cT\u003e {\n    postorder_stack: VecDeque\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for ControlFlowIntoIter\u003cT\u003e {\n    type Item = T;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\n// TODO: are the postorder and reverse postorder named opposite right now? Need to actually check this...\nimpl ControlFlow {\n    fn generate_postorder_stack(\u0026self) -\u003e Vec\u003cusize\u003e {\n        let mut postorder_stack = Vec::\u003cusize\u003e::new();\n        postorder_stack.clear();\n        let mut visited = HashSet::\u003cusize\u003e::new();\n\n        let mut dfs_stack = Vec::\u003cusize\u003e::new();\n        dfs_stack.push(0);\n\n        // go until done\n        while dfs_stack.len() \u003e 0 {\n            match dfs_stack.pop() {\n                Some(label) =\u003e {\n                    // only visit once\n                    if !visited.contains(\u0026label) {\n                        visited.insert(label);\n\n                        postorder_stack.push(label);\n\n                        for successor in \u0026self.block_for_label(\u0026label).successors {\n                            dfs_stack.push(*successor);\n                        }\n                    }\n                }\n                None =\u003e {}\n            }\n        }\n        postorder_stack\n    }\n\n    pub fn blocks_postorder(\u0026self) -\u003e HashMapOOOIter\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIter::new(\u0026self.blocks, postorder_stack)\n    }\n\n    pub fn blocks_postorder_mut(\u0026mut self) -\u003e HashMapOOOIterMut\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIterMut::new(\u0026mut self.blocks, postorder_stack)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::midend::ir::*;\n\n    #[test]\n    fn starter_blocks() {\n        let cf = ControlFlow::new();\n\n        assert!(cf.blocks.len() == 2);\n        assert!(cf.max_block == 1);\n    }\n\n    #[test]\n    fn get_block_for_label() {\n        let mut cf = ControlFlow::new();\n\n        assert_eq!(cf.block_for_label(\u00260).label, 0);\n\n        assert_eq!(cf.block_mut_for_label(0).label, 0);\n        assert_eq!(cf.block_mut_for_label(999).label, 999);\n    }\n\n    #[test]\n    fn append_statement_to_block() {\n        let mut cf = ControlFlow::new();\n\n        let assignment = IrLine::new_assignment(\n            SourceLoc::none(),\n            Operand::new_as_variable(\"dest\".into()),\n            Operand::new_as_variable(\"source\".into()),\n        );\n        assert_eq!(cf.append_statement_to_block(assignment, 0), (None, None));\n    }\n\n    #[test]\n    fn append_unconditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(SourceLoc::none(), 1, JumpCondition::Unconditional);\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), None));\n    }\n\n    #[test]\n    fn append_conditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a\".into()),\n                b: Operand::new_as_variable(\"eq_b\".into()),\n            }),\n        );\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), Some(2)));\n\n        let second_jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a2\".into()),\n                b: Operand::new_as_variable(\"eq_b2\".into()),\n            }),\n        );\n        assert_eq!(\n            cf.append_statement_to_block(second_jump, 0),\n            (Some(1), Some(3))\n        );\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":17}},{"line":31,"address":[],"length":0,"stats":{"Line":17}},{"line":32,"address":[],"length":0,"stats":{"Line":17}},{"line":33,"address":[],"length":0,"stats":{"Line":17}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":40}},{"line":46,"address":[],"length":0,"stats":{"Line":40}},{"line":47,"address":[],"length":0,"stats":{"Line":40}},{"line":50,"address":[],"length":0,"stats":{"Line":22}},{"line":51,"address":[],"length":0,"stats":{"Line":22}},{"line":52,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":68,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":14}},{"line":90,"address":[],"length":0,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":87},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","mod.rs"],"content":"pub mod control_flow;\npub mod operands;\npub mod operations;\nmod tests;\n\nuse std::collections::BTreeSet;\nuse std::fmt::Display;\n\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::ir;\nuse serde::Serialize;\n\npub use control_flow::ControlFlow;\npub use operands::*;\npub use operations::*;\n\n#[derive(Debug, Serialize, Clone)]\npub struct IrLine {\n    pub loc: SourceLoc,\n    pub operation: Operations,\n}\n\nimpl Display for IrLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.operation)\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct BasicBlock {\n    pub label: usize,\n    pub statements: Vec\u003cir::IrLine\u003e,\n    pub arguments: BTreeSet\u003cir::OperandName\u003e,\n    pub successors: BTreeSet\u003cusize\u003e,\n    pub predecessors: BTreeSet\u003cusize\u003e,\n}\n\nimpl BasicBlock {\n    pub fn new(label: usize) -\u003e Self {\n        BasicBlock {\n            statements: Vec::new(),\n            label: label,\n            arguments: BTreeSet::new(),\n            successors: BTreeSet::\u003cusize\u003e::new(),\n            predecessors: BTreeSet::\u003cusize\u003e::new(),\n        }\n    }\n}\n\nimpl IrLine {\n    fn new(loc: SourceLoc, operation: Operations) -\u003e Self {\n        IrLine {\n            loc: loc,\n            operation: operation,\n        }\n    }\n\n    pub fn new_assignment(loc: SourceLoc, destination: Operand, source: Operand) -\u003e Self {\n        Self::new(loc, Operations::new_assignment(destination, source))\n    }\n\n    pub fn new_binary_op(loc: SourceLoc, op: BinaryOperations) -\u003e Self {\n        Self::new(loc, Operations::BinaryOperation(op))\n    }\n\n    pub fn new_jump(\n        loc: SourceLoc,\n        destination_block: usize,\n        condition: operands::JumpCondition,\n    ) -\u003e Self {\n        Self::new(loc, Operations::new_jump(destination_block, condition))\n    }\n\n    pub fn read_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e match \u0026source_dest.source.get_name() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026operation.raw_operands().sources;\n                match sources.a.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values() {\n                    operand_names.push(arg);\n                }\n            }\n        }\n        operand_names\n    }\n\n    pub fn read_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e match source_dest.source.get_name_mut() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026mut operation.raw_operands_mut().sources;\n                match sources.a.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026mut jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values_mut() {\n                    operand_names.push(arg);\n                }\n            }\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(\u0026source_dest.destination.get_name().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands();\n                operand_names.push(\u0026arithmetic_operands.destination.get_name().unwrap());\n            }\n            Operations::Jump(_) =\u003e {}\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operands: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operands.push(source_dest.destination.get_name_mut().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands_mut();\n                operands.push(arithmetic_operands.destination.get_name_mut().unwrap());\n            }\n            Operations::Jump(_) =\u003e {}\n        }\n\n        operands\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":74}},{"line":41,"address":[],"length":0,"stats":{"Line":74}},{"line":43,"address":[],"length":0,"stats":{"Line":74}},{"line":44,"address":[],"length":0,"stats":{"Line":74}},{"line":45,"address":[],"length":0,"stats":{"Line":74}},{"line":51,"address":[],"length":0,"stats":{"Line":33}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":71,"address":[],"length":0,"stats":{"Line":13}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":178,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":182,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":194,"address":[],"length":0,"stats":{"Line":8}}],"covered":80,"coverable":96},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","operands.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{linearizer, types::Type};\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub struct OperandName {\n    pub base_name: String,\n    pub ssa_number: Option\u003cusize\u003e,\n}\n\nimpl PartialEq for OperandName {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        (self.base_name == other.base_name) \u0026\u0026 (self.ssa_number == other.ssa_number)\n    }\n}\n\nimpl Eq for OperandName {}\n\nimpl PartialOrd for OperandName {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        Some(\n            self.base_name\n                .cmp(\u0026other.base_name)\n                .then(match self.ssa_number {\n                    Some(self_ssa_number) =\u003e match other.ssa_number {\n                        Some(other_ssa_number) =\u003e self_ssa_number.cmp(\u0026other_ssa_number),\n                        None =\u003e std::cmp::Ordering::Greater,\n                    },\n                    None =\u003e match other.ssa_number {\n                        Some(_) =\u003e std::cmp::Ordering::Less,\n                        None =\u003e std::cmp::Ordering::Equal,\n                    },\n                }),\n        )\n    }\n}\n\nimpl Ord for OperandName {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Display for OperandName {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self.ssa_number {\n            Some(number) =\u003e {\n                write!(f, \"{}.{}\", self.base_name, number)\n            }\n            None =\u003e write!(f, \"{}\", self.base_name),\n        }\n    }\n}\n\nimpl OperandName {\n    pub fn new_basic(base_name: String) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: None,\n        }\n    }\n\n    fn new_ssa(base_name: String, ssa_number: usize) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: Some(ssa_number),\n        }\n    }\n\n    pub fn into_non_ssa(mut self) -\u003e Self {\n        self.ssa_number = None;\n        self\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub enum Operand {\n    Variable(OperandName),\n    Temporary(OperandName),\n    UnsignedDecimalConstant(usize),\n}\n\nimpl Display for Operand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Variable(name) =\u003e {\n                // write!(f, \"[V {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::Temporary(name) =\u003e {\n                // write!(f, \"[T {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::UnsignedDecimalConstant(value) =\u003e {\n                // write!(f, \"[C {}]\", value)\n                write!(f, \"{}\", value)\n            }\n        }\n    }\n}\n\nimpl PartialEq for Operand {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.cmp(other) == std::cmp::Ordering::Equal\n    }\n}\n\nimpl Eq for Operand {}\n\nimpl PartialOrd for Operand {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        match (self, other) {\n            (Operand::Variable(var_self), Operand::Variable(var_other)) =\u003e {\n                Some(var_self.cmp(var_other))\n            }\n            (Operand::Temporary(temp_self), Operand::Temporary(temp_other)) =\u003e {\n                Some(temp_self.cmp(temp_other))\n            }\n            (\n                Operand::UnsignedDecimalConstant(value_self),\n                Operand::UnsignedDecimalConstant(value_other),\n            ) =\u003e Some(value_self.cmp(value_other)),\n            (_, _) =\u003e None,\n        }\n    }\n}\n\nimpl Ord for Operand {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let partial_result = self.partial_cmp(other);\n\n        match partial_result {\n            Some(ordering) =\u003e ordering,\n            None =\u003e match (self, other) {\n                (Operand::Variable(_), Operand::Temporary(_)) =\u003e std::cmp::Ordering::Greater,\n                (Operand::Variable(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::Temporary(_), Operand::Variable(_)) =\u003e std::cmp::Ordering::Less,\n                (Operand::Temporary(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Variable(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Temporary(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n\n                (Operand::Variable(_), Operand::Variable(_))\n                | (Operand::Temporary(_), Operand::Temporary(_))\n                | (Operand::UnsignedDecimalConstant(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    panic!(\"Non-covered case in Operand::cmp\")\n                }\n            },\n        }\n    }\n}\n\nimpl Operand {\n    pub fn new_as_variable(identifier: String) -\u003e Self {\n        Operand::Variable(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_temporary(identifier: String) -\u003e Self {\n        Operand::Temporary(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_unsigned_decimal_constant(constant: usize) -\u003e Self {\n        Operand::UnsignedDecimalConstant(constant)\n    }\n\n    pub fn type_\u003c'a\u003e(\u0026self, context: \u0026'a linearizer::walkcontext::WalkContext) -\u003e \u0026'a Type {\n        match self {\n            Operand::Variable(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::Temporary(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::UnsignedDecimalConstant(value) =\u003e {\n                if *value \u003e (u32::MAX as usize) {\n                    \u0026Type::U64\n                } else if *value \u003e (u16::MAX as usize) {\n                    \u0026Type::U32\n                } else if *value \u003e (u8::MAX as usize) {\n                    \u0026Type::U16\n                } else {\n                    \u0026Type::U8\n                }\n            }\n        }\n    }\n\n    pub fn get_name(\u0026self) -\u003e Option\u003c\u0026OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n\n    pub fn get_name_mut(\u0026mut self) -\u003e Option\u003c\u0026mut OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n}\n\n/*\n groupings of operands\n*/\n\n#[derive(Debug, Serialize, Clone)]\npub struct DualSourceOperands {\n    pub a: Operand,\n    pub b: Operand,\n}\n\nimpl DualSourceOperands {\n    pub fn new(a: Operand, b: Operand) -\u003e Self {\n        DualSourceOperands { a, b }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct BinaryArithmeticOperands {\n    pub destination: Operand,\n    pub sources: DualSourceOperands,\n}\n\nimpl BinaryArithmeticOperands {\n    pub fn from(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryArithmeticOperands {\n            destination,\n            sources: DualSourceOperands::new(source_a, source_b),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct SourceDestOperands {\n    pub destination: Operand,\n    pub source: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub enum JumpCondition {\n    Unconditional,\n    Eq(DualSourceOperands),\n    NE(DualSourceOperands),\n    GT(DualSourceOperands),\n    LT(DualSourceOperands),\n    GE(DualSourceOperands),\n    LE(DualSourceOperands),\n}\n\nimpl Display for JumpCondition {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unconditional =\u003e {\n                write!(f, \"jmp\")\n            }\n            Self::Eq(operands) =\u003e {\n                write!(f, \"jeq({}, {})\", operands.a, operands.b)\n            }\n            Self::NE(operands) =\u003e {\n                write!(f, \"jne({}, {})\", operands.a, operands.b)\n            }\n            Self::LT(operands) =\u003e {\n                write!(f, \"jl({}, {})\", operands.a, operands.b)\n            }\n            Self::GT(operands) =\u003e {\n                write!(f, \"jg({}, {})\", operands.a, operands.b)\n            }\n            Self::LE(operands) =\u003e {\n                write!(f, \"jle({}, {})\", operands.a, operands.b)\n            }\n            Self::GE(operands) =\u003e {\n                write!(f, \"jge({}, {})\", operands.a, operands.b)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::midend::ir::*;\n\n    #[test]\n    fn operand_name_ord() {\n        // non-ssa operand names\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"b\".into())),\n            Ordering::Less\n        );\n\n        // ssa operand names\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 4)),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 5)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"b\".into(), 4)),\n            Ordering::Less\n        );\n\n        // mixed ssa and non-ssa\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_ssa(\"a\".into(), 1)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 1).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn operand_name_into_non_ssa() {\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 123).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n    }\n\n    #[test]\n    fn operand_eq() {\n        // variable against other types\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // temporary against other types\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // unsigned decimal constant against other types\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n    }\n\n    #[test]\n    fn operand_get_name() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name(),\n            None\n        );\n    }\n\n    #[test]\n    fn operand_get_name_mut() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name_mut(),\n            None\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":40}},{"line":15,"address":[],"length":0,"stats":{"Line":80}},{"line":22,"address":[],"length":0,"stats":{"Line":9}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":25,"address":[],"length":0,"stats":{"Line":9}},{"line":26,"address":[],"length":0,"stats":{"Line":9}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":112}},{"line":65,"address":[],"length":0,"stats":{"Line":9}},{"line":68,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":9}},{"line":113,"address":[],"length":0,"stats":{"Line":9}},{"line":114,"address":[],"length":0,"stats":{"Line":9}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":132,"address":[],"length":0,"stats":{"Line":9}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":54}},{"line":164,"address":[],"length":0,"stats":{"Line":54}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":11}},{"line":172,"address":[],"length":0,"stats":{"Line":11}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":20}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":201,"address":[],"length":0,"stats":{"Line":18}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":20}},{"line":208,"address":[],"length":0,"stats":{"Line":20}},{"line":209,"address":[],"length":0,"stats":{"Line":18}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":3}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}}],"covered":65,"coverable":107},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","operations.rs"],"content":"use serde::Serialize;\nuse std::{collections::HashMap, fmt::Display};\n\nuse super::operands::*;\n\n/// ## Binary Operations\n#[derive(Debug, Serialize, Clone)]\npub enum BinaryOperations {\n    Add(BinaryArithmeticOperands),\n    Subtract(BinaryArithmeticOperands),\n    Multiply(BinaryArithmeticOperands),\n    Divide(BinaryArithmeticOperands),\n    LThan(BinaryArithmeticOperands),\n    GThan(BinaryArithmeticOperands),\n    LThanE(BinaryArithmeticOperands),\n    GThanE(BinaryArithmeticOperands),\n    Equals(BinaryArithmeticOperands),\n    NotEquals(BinaryArithmeticOperands),\n}\n\nimpl Display for BinaryOperations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} + {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Subtract(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} - {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Multiply(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} * {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Divide(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} / {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Equals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} == {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::NotEquals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} != {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n        }\n    }\n}\n\nimpl BinaryOperations {\n    pub fn new_add(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Add(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_subtract(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Subtract(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_multiply(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Multiply(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_divide(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Divide(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Equals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_not_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::NotEquals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn raw_operands(\u0026self) -\u003e \u0026BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n\n    pub fn raw_operands_mut(\u0026mut self) -\u003e \u0026mut BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n}\n\n/// ## Jump\n#[derive(Debug, Serialize, Clone)]\npub struct JumpOperation {\n    pub destination_block: usize,\n    pub block_args: HashMap\u003cOperandName, OperandName\u003e,\n    pub condition: JumpCondition,\n}\n\nimpl Display for JumpOperation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut block_args_string = String::new();\n        for (arg, operand) in \u0026self.block_args {\n            block_args_string += \u0026format!(\"{}:{} \", arg, operand);\n        }\n        write!(\n            f,\n            \"{} Block{}({})\",\n            self.condition, self.destination_block, block_args_string\n        )\n    }\n}\n\nimpl JumpOperation {\n    pub fn new(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self {\n            destination_block,\n            block_args: HashMap::new(),\n            condition,\n        }\n    }\n}\n\n/// ## Enum of all operations\n#[derive(Debug, Serialize, Clone)]\npub enum Operations {\n    Assignment(SourceDestOperands),\n    BinaryOperation(BinaryOperations),\n    Jump(JumpOperation),\n}\n\nimpl Display for Operations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{} = {}\", assignment.destination, assignment.source)\n            }\n            Self::BinaryOperation(binary_operation) =\u003e {\n                write!(f, \"{}\", binary_operation)\n            }\n            Self::Jump(jump) =\u003e {\n                write!(f, \"{}\", jump)\n            }\n        }\n    }\n}\n\nimpl Operations {\n    pub fn new_assignment(destination: Operand, source: Operand) -\u003e Self {\n        Self::Assignment(SourceDestOperands {\n            destination,\n            source,\n        })\n    }\n\n    pub fn new_jump(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self::Jump(JumpOperation::new(destination_block, condition))\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":25}},{"line":236,"address":[],"length":0,"stats":{"Line":25}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":274,"address":[],"length":0,"stats":{"Line":13}},{"line":275,"address":[],"length":0,"stats":{"Line":13}}],"covered":26,"coverable":139},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","tests.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend::ir::*};\n\nuse super::{IrLine, Operand};\n\n#[test]\nfn ir_line_new_assignment() {\n    let assignment = IrLine::new_assignment(\n        SourceLoc::new(123, 456),\n        Operand::new_as_variable(\"a\".into()),\n        Operand::new_as_unsigned_decimal_constant(99),\n    );\n\n    assert_eq!(assignment.loc, SourceLoc::new(123, 456));\n    assert!(matches!(assignment.operation, Operations::Assignment(_)));\n}\n\n#[test]\nfn ir_line_new_binary_op() {\n    let binary_operation = IrLine::new_binary_op(\n        SourceLoc::new(123, 456),\n        BinaryOperations::new_add(\n            Operand::new_as_variable(\"result\".into()),\n            Operand::new_as_variable(\"a\".into()),\n            Operand::new_as_variable(\"b\".into()),\n        ),\n    );\n\n    assert_eq!(binary_operation.loc, SourceLoc::new(123, 456));\n    assert!(matches!(\n        binary_operation.operation,\n        Operations::BinaryOperation(_)\n    ));\n}\n\n#[test]\nfn ir_line_new_jump() {\n    let jump = IrLine::new_jump(SourceLoc::new(123, 456), 8, JumpCondition::Unconditional);\n\n    assert_eq!(jump.loc, SourceLoc::new(123, 456));\n    assert!(matches!(jump.operation, Operations::Jump(_)));\n}\n\nfn operand_from_string(name: \u0026str) -\u003e Operand {\n    Operand::new_as_variable(name.into())\n}\n\nfn line_from_op(operation: Operations) -\u003e IrLine {\n    IrLine::new(SourceLoc::new(0, 0), operation)\n}\n\nfn operand_name_from_string(name: \u0026str) -\u003e OperandName {\n    OperandName::new_basic(name.into())\n}\n\n#[test]\nfn read_operand_names() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n\n#[test]\nfn read_operand_names_mut() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","mod.rs"],"content":"use treewalk::TableWalk;\n\nuse crate::frontend::ast::TranslationUnitTree;\n\nuse super::symtab::SymbolTable;\n\nmod treewalk;\npub mod walkcontext;\n\npub fn linearize(symtab: \u0026mut SymbolTable, program: Vec\u003cTranslationUnitTree\u003e) {\n    for translation_unit in program {\n        translation_unit.walk(symtab);\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","treewalk.rs"],"content":"use crate::{\n    frontend::{ast::*, sourceloc::SourceLoc},\n    midend::{\n        ir::{self, IrLine},\n        symtab::{self, SymbolTable},\n        types::Type,\n    },\n};\n\nuse super::walkcontext::WalkContext;\n\npub trait TableWalk {\n    fn walk(self, symbol_table: \u0026mut SymbolTable);\n}\n\npub trait ReturnWalk\u003cT\u003e {\n    fn walk(self) -\u003e T;\n}\n\npub trait ContextWalk {\n    fn walk(self, context: \u0026mut WalkContext);\n}\n\npub trait OperandWalk {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand;\n}\n\nimpl TableWalk for TranslationUnitTree {\n    fn walk(self, symbol_table: \u0026mut SymbolTable) {\n        match self.contents {\n            TranslationUnit::FunctionDeclaration(tree) =\u003e {\n                let declared_function = tree.walk();\n                symbol_table.insert_function_prototype(declared_function);\n            }\n            TranslationUnit::FunctionDefinition(tree) =\u003e {\n                let mut declared_prototype = tree.prototype.walk();\n                let mut context = WalkContext::new();\n                context.push_scope(declared_prototype.create_argument_scope());\n\n                tree.body.walk(\u0026mut context);\n                let argument_scope = context.pop_last_scope();\n\n                symbol_table.insert_function(symtab::Function::new(\n                    declared_prototype,\n                    argument_scope,\n                    context.take_control_flow(),\n                ));\n            }\n        }\n    }\n}\n\nimpl ReturnWalk\u003cType\u003e for TypenameTree {\n    fn walk(self) -\u003e Type {\n        self.type_\n    }\n}\n\nimpl ReturnWalk\u003csymtab::Variable\u003e for VariableDeclarationTree {\n    fn walk(self) -\u003e symtab::Variable {\n        symtab::Variable::new(self.name.clone(), self.typename.walk())\n    }\n}\n\nimpl ReturnWalk\u003csymtab::FunctionPrototype\u003e for FunctionDeclarationTree {\n    fn walk(self) -\u003e symtab::FunctionPrototype {\n        symtab::FunctionPrototype::new(\n            self.name,\n            self.arguments.into_iter().map(|x| x.walk()).collect(),\n            match self.return_type {\n                Some(typename) =\u003e Some(typename.walk()),\n                None =\u003e None,\n            },\n        )\n    }\n}\n\nimpl OperandWalk for ArithmeticOperationTree {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        let (temp_dest, op) = match self {\n            ArithmeticOperationTree::Add(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_add(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Subtract(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_subtract(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Multiply(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_multiply(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Divide(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_divide(dest, lhs, rhs),\n                )\n            }\n        };\n\n        let operation = IrLine::new_binary_op(loc, op);\n        context.append_statement_to_current_block(operation);\n        temp_dest\n    }\n}\n\nimpl OperandWalk for ComparisonOperationTree {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        let (temp_dest, op) = match self {\n            ComparisonOperationTree::LThan(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::GThan(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::LThanE(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::GThanE(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::Equals(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_equals(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::NotEquals(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_not_equals(dest, lhs, rhs),\n                )\n            }\n        };\n        let operation = IrLine::new_binary_op(loc, op);\n        context.append_statement_to_current_block(operation);\n        temp_dest\n    }\n}\n\nimpl OperandWalk for ExpressionTree {\n    fn walk(self, _loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        match self.expression {\n            Expression::Identifier(ident) =\u003e ir::Operand::new_as_variable(ident),\n            Expression::UnsignedDecimalConstant(constant) =\u003e {\n                ir::Operand::new_as_unsigned_decimal_constant(constant)\n            }\n            Expression::Arithmetic(arithmetic_operation) =\u003e {\n                arithmetic_operation.walk(self.loc, context)\n            }\n            Expression::Comparison(comparison_operation) =\u003e {\n                comparison_operation.walk(self.loc, context)\n            }\n        }\n    }\n}\n\nimpl ContextWalk for AssignmentTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        let assignment_ir = IrLine::new_assignment(\n            self.loc,\n            ir::Operand::new_as_variable(self.identifier),\n            self.value.walk(self.loc, context),\n        );\n        context.append_statement_to_current_block(assignment_ir);\n    }\n}\n\nimpl ContextWalk for IfStatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        // FUTURE: optimize condition walk to use different jumps\n        let condition_loc = self.condition.loc.clone();\n        let condition_result = self.condition.walk(condition_loc, context);\n        let if_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n\n        let (_, maybe_else_label) =\n            context.create_conditional_branch_from_current(condition_loc, if_condition);\n        self.true_block.walk(context);\n        context.converge_current_block();\n\n        match (maybe_else_label, self.false_block) {\n            (Some(else_label), Some(else_block)) =\u003e {\n                context.set_current_block(else_label);\n                else_block.walk(context);\n                context.converge_current_block();\n            }\n            (None, None) =\u003e {}\n            (_, _) =\u003e {\n                panic!(\n                    \"Mismatched else label and else block - expect to have either both or neither\"\n                );\n            }\n        };\n    }\n}\n\nimpl ContextWalk for WhileLoopTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        let loop_done = context.create_loop(self.loc, self.condition);\n\n        self.body.walk(context);\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n    }\n}\n\nimpl ContextWalk for StatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        match self.statement {\n            Statement::VariableDeclaration(tree) =\u003e context.scope().insert_variable(tree.walk()),\n            Statement::Assignment(tree) =\u003e tree.walk(context),\n            Statement::IfStatement(tree) =\u003e tree.walk(context),\n            Statement::WhileLoop(tree) =\u003e tree.walk(context),\n        }\n    }\n}\n\nimpl ContextWalk for CompoundStatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        context.push_scope(symtab::Scope::new());\n        for statement in self.statements {\n            statement.walk(context);\n        }\n        context.pop_scope_to_subscope_of_next();\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":143},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","walkcontext.rs"],"content":"use std::collections::{HashMap, HashSet};\n\nuse crate::{\n    frontend::{ast, sourceloc::SourceLoc},\n    midend::{ir, symtab, types::Type},\n};\n\nuse super::treewalk::*;\n\npub struct WalkContext {\n    control_flow: ir::ControlFlow,\n    branch_points: HashMap\u003cusize, HashSet\u003cusize\u003e\u003e, // map from branch origin to set of target blocks\n    convergence_points: HashMap\u003cusize, usize\u003e, // map of label -\u003e label that block should jump to when done\n    scopes: Vec\u003csymtab::Scope\u003e,\n    // index of number of temporary variables used in this control flow (across all blocks)\n    temp_num: usize,\n    current_block: usize,\n}\n\nimpl WalkContext {\n    pub fn new() -\u003e WalkContext {\n        let starter_flow = ir::ControlFlow::new();\n\n        let mut convergence_points = HashMap::\u003cusize, usize\u003e::new();\n        convergence_points.insert(0, 1);\n\n        WalkContext {\n            control_flow: starter_flow,\n            branch_points: HashMap::\u003cusize, HashSet\u003cusize\u003e\u003e::new(),\n            convergence_points,\n            scopes: Vec::new(),\n            temp_num: 0,\n            current_block: 0,\n        }\n    }\n\n    pub fn take_control_flow(mut self) -\u003e ir::ControlFlow {\n        for (from, to) in self.convergence_points.clone() {\n            assert_eq!(self.converge_block(from), to); // TODO: need assert?\n        }\n        self.control_flow\n    }\n\n    fn replace_branch_and_convergence_points(\u0026mut self, old_block: usize, new_block: usize) {\n        // replace all instances of old_block with new_block in both branch and convergence point tracking\n        // self.branch_points = self\n        //     .branch_points\n        //     .iter()\n        //     .map(|(source, dest_set)| {\n        //         (\n        //             if *source == old_block {\n        //                 new_block\n        //             } else {\n        //                 *source\n        //             },\n        //             dest_set\n        //                 .into_iter()\n        //                 .map(|target| {\n        //                     if *target == old_block {\n        //                         new_block\n        //                     } else {\n        //                         *target\n        //                     }\n        //                 })\n        //                 .collect(),\n        //         )\n        //     })\n        //     .collect();\n\n        self.convergence_points = self\n            .convergence_points\n            .iter()\n            .map(|(from, to)| {\n                (\n                    if *from == old_block { new_block } else { *from },\n                    if *to == old_block { new_block } else { *to },\n                )\n            })\n            .collect();\n    }\n\n    pub fn append_statement_to_current_block(\u0026mut self, statement: ir::IrLine) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(_) =\u003e {\n                panic!(\"WalkContext::append_statement_to_current_block does NOT support jumps!\")\n            }\n            _ =\u003e {}\n        }\n        self.append_to_current_block(statement);\n    }\n\n    ///appends the given statement to the current basic block\n    ///if the statement is any sort of branch, the current block will be updated to be the target of the branch\n    ///if the branch is conditional, the function returns Some(false_label) where false_label is the target of the\n    ///block control flows to when the condition is not met\n    ///for unconditional branches and other statements, returns None\n    fn append_to_current_block(\u0026mut self, statement: ir::IrLine) -\u003e Option\u003cusize\u003e {\n        match self\n            .control_flow\n            .append_statement_to_block(statement, self.current_block)\n        {\n            (Some(new_current), false_label) =\u003e {\n                self.replace_branch_and_convergence_points(self.current_block, new_current);\n                self.set_current_block(new_current);\n                false_label\n            }\n            (None, _) =\u003e None,\n        }\n    }\n\n    /// creates a branch from the current block based on a condition\n    /// returns the target of the branch\n    fn create_branch_from_current(\u0026mut self) -\u003e usize {\n        let branch_target = self.control_flow.next_block();\n\n        match self.branch_points.get(\u0026self.current_block) {\n            Some(_) =\u003e panic!(\n                \"create_branch_from_current called with existing branch (from block {})\",\n                self.current_block\n            ),\n            None =\u003e {\n                self.branch_points\n                    .insert(self.current_block, HashSet::new());\n            }\n        };\n\n        self.branch_points\n            .get_mut(\u0026self.current_block)\n            .unwrap()\n            .insert(branch_target);\n        branch_target\n    }\n\n    fn add_branch(\u0026mut self, from: usize, to: usize) {\n        self.branch_points\n            .get_mut(\u0026from)\n            .expect(\"add_branch expects existing branch\")\n            .insert(to);\n    }\n\n    fn add_convergence_point_for_branch(\u0026mut self, from: usize, to: usize) {\n        match self.convergence_points.insert(from, to) {\n            Some(existing_convergence) =\u003e {\n                if existing_convergence != to {\n                    self.add_convergence_point_for_branch(to, existing_convergence);\n                }\n            }\n            None =\u003e {}\n        }\n    }\n\n    fn create_convergence_points_for_branch(\u0026mut self, branch_from: usize) -\u003e usize {\n        let convergence_point = match self.convergence_points.get(\u0026branch_from) {\n            Some(existing_convergence) =\u003e *existing_convergence,\n            None =\u003e self.control_flow.next_block(),\n        };\n\n        for branch_target in self\n            .branch_points\n            .get(\u0026branch_from)\n            .expect(\"Creation of convergence points requires existence of branch(es)\")\n            .clone()\n        {\n            self.add_convergence_point_for_branch(branch_target, convergence_point);\n        }\n        convergence_point\n    }\n\n    ///append an unconditional jump from the end of block_label to its convergence point\n    ///return the block to which control has converged\n    fn converge_block(\u0026mut self, block_label: usize) -\u003e usize {\n        let converge_to = self\n            .convergence_points\n            .remove(\u0026block_label)\n            .expect(\u0026format!(\"Block {} has no convergence point\", block_label));\n\n        let convergence_jump = ir::IrLine::new_jump(\n            SourceLoc::none(),\n            converge_to,\n            ir::JumpCondition::Unconditional,\n        );\n        // ignore return value - appending an unconditional jump\n        self.control_flow\n            .append_statement_to_block(convergence_jump, block_label);\n        converge_to\n    }\n\n    pub fn converge_current_block(\u0026mut self) {\n        let converged_to = self.converge_block(self.current_block);\n        self.set_current_block(converged_to);\n    }\n\n    pub fn set_current_block(\u0026mut self, label: usize) {\n        self.current_block = label;\n    }\n\n    pub fn create_conditional_branch_from_current(\n        \u0026mut self,\n        loc: SourceLoc,\n        condition: ir::JumpCondition,\n    ) -\u003e (usize, Option\u003cusize\u003e) {\n        let branch_origin = self.current_block;\n        let true_label = self.create_branch_from_current();\n\n        let true_condition_jump = ir::IrLine::new_jump(loc, true_label, condition);\n        let maybe_false_label = self.append_to_current_block(true_condition_jump);\n        match maybe_false_label {\n            Some(false_label) =\u003e self.add_branch(branch_origin, false_label),\n            None =\u003e {}\n        }\n\n        self.create_convergence_points_for_branch(branch_origin);\n\n        (true_label, maybe_false_label)\n    }\n\n    ///returns the label which control jumps to after the loop\n    pub fn create_loop(\u0026mut self, loc: SourceLoc, condition: ast::ExpressionTree) -\u003e usize {\n        // first, jump to a fresh block which will be the top of the loop\n        let loop_top = self.control_flow.next_block();\n        let loop_entry = ir::IrLine::new_jump(loc, loop_top, ir::JumpCondition::Unconditional);\n        // ignore return value - appending an unconditional jump\n        self.append_to_current_block(loop_entry);\n\n        // FUTURE: optimize condition walk to use different jumps\n        // check the condition of the loop, giving us the loop body and loop done labels\n        let condition_loc = condition.loc.clone();\n        let condition_result = condition.walk(condition_loc, self);\n        let loop_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n        let (_, loop_done_label) =\n            self.create_conditional_branch_from_current(condition_loc, loop_condition);\n        let loop_done_label = loop_done_label.unwrap();\n\n        self.convergence_points.insert(self.current_block, loop_top);\n        self.converge_block(loop_done_label);\n\n        loop_done_label\n    }\n\n    pub fn next_temp(\u0026mut self, type_: Type) -\u003e ir::Operand {\n        let temp_name = String::from(\".T\") + \u0026self.temp_num.to_string();\n        self.temp_num += 1;\n        self.scope()\n            .insert_variable(symtab::Variable::new(temp_name.clone(), type_));\n        ir::Operand::new_as_temporary(temp_name)\n    }\n\n    pub fn push_scope(\u0026mut self, scope: symtab::Scope) {\n        self.scopes.push(scope)\n    }\n\n    pub fn pop_scope_to_subscope_of_next(\u0026mut self) {\n        let popped = self\n            .scopes\n            .pop()\n            .expect(\"WalkContext::pop_scope_to_subscope_of_next expects valid scope\");\n        self.scope().insert_subscope(popped);\n    }\n\n    pub fn pop_last_scope(\u0026mut self) -\u003e symtab::Scope {\n        if self.scopes.len() \u003e 1 {\n            panic!(\n                \"WalkContext::pop_last_scope() called with {} parent scopes\",\n                self.scopes.len()\n            );\n        }\n\n        self.scopes\n            .pop()\n            .expect(\"WalkContext::pop_last_scope() called with no scopese\")\n    }\n\n    pub fn scope(\u0026mut self) -\u003e \u0026mut symtab::Scope {\n        self.scopes\n            .last_mut()\n            .expect(\"WalkContext::scope() expects valid scope\")\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026ir::OperandName) -\u003e Option\u003c\u0026symtab::Variable\u003e {\n        for scope in (\u0026self.scopes).into_iter().rev().by_ref() {\n            match scope.lookup_variable_by_name(\u0026name.base_name) {\n                Some(variable) =\u003e return Some(variable),\n                None =\u003e {}\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        frontend::{ast, sourceloc::SourceLoc},\n        midend::{ir, linearizer::walkcontext::WalkContext, symtab},\n    };\n\n    fn assert_no_remaining_convergences(context: WalkContext) {\n        // allow convergence to block 1 as that should be the final block in the control flow\n        for (from, to) in context.convergence_points {\n            assert_eq!(to, 1);\n        }\n    }\n\n    fn assert_branch(context: \u0026WalkContext, from: usize, to: usize) {\n        let branches = context.branch_points.get(\u0026from);\n        assert!(branches.is_some());\n        let branches = branches.unwrap();\n        assert!(branches.contains(\u0026to));\n    }\n\n    fn assert_convergence(context: \u0026WalkContext, from: usize, to: usize) {\n        let convergence = context.convergence_points.get(\u0026from);\n        assert_eq!(convergence, Some(\u0026to));\n    }\n\n    #[test]\n    fn walk_context_initial_state() {\n        let context = WalkContext::new();\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn append_statement() {\n        let mut context = WalkContext::new();\n        let assignment = ir::IrLine::new_assignment(\n            SourceLoc::none(),\n            ir::Operand::new_as_variable(\"dest\".into()),\n            ir::Operand::new_as_variable(\"source\".into()),\n        );\n        context.append_statement_to_current_block(assignment);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_branch() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n    }\n\n    #[test]\n    fn add_branch() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n        assert_eq!(branch_to, 2);\n        assert_eq!(second_branch_to, 3);\n    }\n\n    #[test]\n    fn simple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n    }\n\n    #[test]\n    fn complex_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        // create the convergence point and assert that both branch targets converge to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn simple_multiple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 2 targets, nested in a branch with one target\n    #[test]\n    fn complex_multiple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // and add to that second branch a second target\n        let second_nested_branch_to = context.control_flow.next_block();\n        context.add_branch(nested_branch_from, second_nested_branch_to);\n        assert_branch(\u0026context, nested_branch_from, second_nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 1 target, nested within a branch with 2 targets\n    #[test]\n    fn complex_multiple_branch_convergence_points_2() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_to, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(branch_to);\n        assert_convergence(\u0026context, branch_to, nested_converge_to);\n\n        // and re-assert our original convergence\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn converge_block() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        assert_eq!(context.converge_block(branch_to), converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn converge_current_block() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        context.set_current_block(branch_to);\n        context.converge_current_block();\n\n        assert_eq!(context.current_block, converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_loop() {\n        let mut context = WalkContext::new();\n        context.push_scope(symtab::Scope::new());\n\n        let before_loop = context.current_block;\n\n        let loop_done = context.create_loop(\n            SourceLoc::none(),\n            ast::ExpressionTree {\n                loc: SourceLoc::none(),\n                expression: { ast::Expression::UnsignedDecimalConstant(123) },\n            },\n        );\n\n        assert_ne!(before_loop, context.current_block);\n        assert_ne!(loop_done, context.current_block);\n\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        assert_no_remaining_convergences(context);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":13}},{"line":114,"address":[],"length":0,"stats":{"Line":13}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":13}},{"line":122,"address":[],"length":0,"stats":{"Line":13}},{"line":123,"address":[],"length":0,"stats":{"Line":13}},{"line":127,"address":[],"length":0,"stats":{"Line":13}},{"line":128,"address":[],"length":0,"stats":{"Line":13}},{"line":130,"address":[],"length":0,"stats":{"Line":13}},{"line":131,"address":[],"length":0,"stats":{"Line":13}},{"line":134,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":142,"address":[],"length":0,"stats":{"Line":16}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":15}},{"line":152,"address":[],"length":0,"stats":{"Line":11}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":154,"address":[],"length":0,"stats":{"Line":10}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":26}},{"line":159,"address":[],"length":0,"stats":{"Line":11}},{"line":160,"address":[],"length":0,"stats":{"Line":11}},{"line":161,"address":[],"length":0,"stats":{"Line":11}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":166,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":9}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}}],"covered":100,"coverable":132},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","mod.rs"],"content":"use symtab::SymbolTable;\n\nuse crate::frontend;\n\nmod idfa;\npub mod ir;\npub mod linearizer;\nmod optimization;\nmod ssa_gen;\npub mod symtab;\npub mod types;\n\npub fn symbol_table_from_program(\n    program: Vec\u003cfrontend::ast::TranslationUnitTree\u003e,\n) -\u003e symtab::SymbolTable {\n    let mut symtab = SymbolTable::new();\n    linearizer::linearize(\u0026mut symtab, program);\n\n    ssa_gen::convert_functions_to_ssa(\u0026mut symtab.functions);\n\n    optimization::optimize_functions(\u0026mut symtab.functions);\n\n    symtab\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","optimization","mod.rs"],"content":"use std::collections::HashMap;\n\nuse super::symtab::{Function, FunctionOrPrototype};\n\nmod unused_blocks;\n\nfn do_optimizations_on_function(function: \u0026mut Function) {\n    // unused_blocks::remove_unused_blocks(function);\n}\n\npub fn optimize_functions(functions: \u0026mut HashMap\u003cString, FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            FunctionOrPrototype::Prototype(_) =\u003e {}\n            FunctionOrPrototype::Function(function) =\u003e do_optimizations_on_function(function),\n        };\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","optimization","unused_blocks.rs"],"content":"// use std::collections::{BTreeSet, HashMap, HashSet};\n\n// use crate::midend::{\n//     ir::{self, ControlFlow},\n//     symtab::Function,\n// };\n\n// pub fn remove_unused_blocks(function: \u0026mut Function) {\n//     let mut block_references = HashMap::\u003cusize, usize\u003e::new();\n\n//     for label_num in 0..function.control_flow.blocks.len() {\n//         block_references.entry(label_num).or_insert(0);\n//         for target in \u0026function.control_flow.successors[label_num] {\n//             *block_references.entry(*target).or_insert(0) += 1;\n//         }\n//     }\n\n//     let mut block_labels_to_remove = BTreeSet::\u003cusize\u003e::new();\n\n//     for (block, rc) in block_references {\n//         println!(\"{}:{}\", block, rc);\n//         if rc == 0 {\n//             block_labels_to_remove.insert(block);\n//         }\n//     }\n\n//     let mut block_labels_to_rename = HashMap::\u003cusize, usize\u003e::new();\n//     for label_num in \u0026block_labels_to_remove {\n//         for affected in *label_num..function.control_flow.blocks.len() {\n//             if !block_labels_to_remove.contains(\u0026affected) {\n//                 *block_labels_to_rename.entry(affected).or_insert(affected) -= 1;\n//             }\n//         }\n//     }\n\n//     for (orig, renamed) in \u0026block_labels_to_rename {\n//         println!(\"{}-\u003e{}\", orig, renamed);\n//     }\n\n//     for block in \u0026mut function.control_flow.blocks {\n//         for statement in block.statements_mut() {\n//             match \u0026mut statement.operation {\n//                 ir::Operations::Jump(jump) =\u003e {\n//                     let original_destination = jump.destination_block;\n//                     jump.destination_block = match block_labels_to_rename.get(\u0026original_destination)\n//                     {\n//                         Some(new_label) =\u003e *new_label,\n//                         None =\u003e original_destination,\n//                     };\n//                 }\n//                 _ =\u003e {}\n//             }\n//         }\n//     }\n\n//     for (old_label, new_label) in \u0026block_labels_to_rename {\n//         function.control_flow.blocks[*old_label].label = *new_label;\n//         println!(\"Rename {}-\u003e{}\", old_label, new_label);\n//     }\n\n//     for remove in block_labels_to_remove.iter().rev() {\n//         println!(\"Remove unused block {}\", remove);\n//         function.control_flow.blocks.remove(*remove);\n//         function.control_flow.successors.remove(*remove);\n//         function.control_flow.predecessors.remove(*remove);\n//     }\n\n//     for predecessor_set in \u0026mut function.control_flow.predecessors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for predecessor in predecessor_set.iter() {\n//             let original_predecessor = predecessor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *predecessor,\n//             });\n//         }\n\n//         *predecessor_set = new_set;\n//     }\n\n//     for successor_set in \u0026mut function.control_flow.successors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for successor in successor_set.iter() {\n//             let original_predecessor = successor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *successor,\n//             });\n//         }\n\n//         *successor_set = new_set;\n//     }\n\n//     function.control_flow.to_graphviz();\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa.rs"],"content":"struct SsaBlock {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","add_block_args.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse crate::midend::idfa::block_args::IdfaImplementor;\nuse crate::midend::{\n    idfa::{self},\n    ir, symtab,\n};\n\npub fn add_block_arguments(function: \u0026mut symtab::Function) {\n    let mut block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n\n    loop {\n        let mut args_by_block = HashMap::\u003cusize, BTreeSet\u003cir::OperandName\u003e\u003e::new();\n        for (label, block) in \u0026mut function.control_flow.blocks {\n            block.arguments = block_args.for_label(*label).out_facts.clone();\n            args_by_block.insert(*label, block.arguments.clone());\n        }\n\n        for block in function.control_flow.blocks.values_mut() {\n            for statement in \u0026mut block.statements {\n                match \u0026mut statement.operation {\n                    ir::Operations::Jump(jump) =\u003e {\n                        for target_arg in args_by_block.get(\u0026jump.destination_block).unwrap() {\n                            jump.block_args\n                                .insert(target_arg.clone(), target_arg.clone());\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        let new_block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n        if new_block_args != block_args {\n            block_args = new_block_args;\n        } else {\n            break;\n        }\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","convert_reads.rs"],"content":"use std::collections::BTreeMap;\n\nuse crate::midend::{idfa::reaching_defs::IdfaImplementor, ir, symtab};\n\npub fn convert_reads_to_ssa(function: \u0026mut symtab::Function) {\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        let mut highest_ssa_numbers = BTreeMap::\u003cir::OperandName, ir::OperandName\u003e::new();\n\n        for arg in \u0026block.arguments {\n            highest_ssa_numbers.insert(arg.clone().into_non_ssa(), arg.clone());\n        }\n\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = match highest_ssa_numbers.get(read) {\n                    Some(operand) =\u003e operand.ssa_number,\n                    None =\u003e {\n                        println!(\"{} has no ssa number (yet)\", read);\n                        None\n                    }\n                };\n            }\n\n            for write in statement.write_operand_names() {\n                match highest_ssa_numbers.get(\u0026write.clone().into_non_ssa()) {\n                    Some(existing_number) =\u003e {\n                        assert!(existing_number.ssa_number.unwrap() \u003c write.ssa_number.unwrap());\n                    }\n                    None =\u003e {}\n                }\n                highest_ssa_numbers.insert(write.clone().into_non_ssa(), write.clone());\n            }\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","convert_writes.rs"],"content":"use std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{ir, symtab};\n\n#[derive(Debug)]\nstruct SsaWriteConversionMetadata {\n    variables: HashMap\u003cString, usize\u003e,\n}\n\nimpl Display for SsaWriteConversionMetadata {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut result: std::fmt::Result = write!(f, \"Variables: {{\");\n\n        for (variable, ssa_number) in \u0026self.variables {\n            result = result.and(writeln!(f, \"{}:{}\", variable, ssa_number));\n        }\n\n        result\n    }\n}\n\nimpl SsaWriteConversionMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            variables: HashMap::new(),\n        }\n    }\n\n    pub fn next_number_for_variable(\u0026mut self, operand_name: \u0026ir::OperandName) -\u003e usize {\n        let entry = self\n            .variables\n            .entry(operand_name.base_name.clone())\n            .or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n\n    pub fn next_number_for_string(\u0026mut self, string: String) -\u003e usize {\n        let entry = self.variables.entry(string).or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n}\n\nfn convert_block_writes_to_ssa(\n    block: \u0026mut ir::BasicBlock,\n    metadata: \u0026mut SsaWriteConversionMetadata,\n) {\n    let old_args = block.arguments.clone();\n    block.arguments.clear();\n\n    for argument in old_args.iter() {\n        let mut new_argument = argument.clone();\n        new_argument.ssa_number = Some(metadata.next_number_for_variable(argument));\n        block.arguments.insert(new_argument);\n    }\n\n    for statement in \u0026mut block.statements {\n        for write in statement.write_operand_names_mut() {\n            write.ssa_number = Some(metadata.next_number_for_variable(write));\n        }\n    }\n}\n\npub fn convert_writes_to_ssa(function: \u0026mut symtab::Function) {\n    let mut write_conversion_metadata = SsaWriteConversionMetadata::new();\n    for argument in \u0026function.prototype.arguments {\n        write_conversion_metadata.next_number_for_string(argument.name());\n    }\n\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        convert_block_writes_to_ssa(block, \u0026mut write_conversion_metadata)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","mod.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse add_block_args::add_block_arguments;\nuse convert_reads::convert_reads_to_ssa;\nuse convert_writes::convert_writes_to_ssa;\n\nmod add_block_args;\nmod convert_reads;\nmod convert_writes;\n\nuse super::{ir, symtab};\n\nfn convert_function_to_ssa(function: \u0026mut symtab::Function) {\n    add_block_arguments(function);\n    convert_writes_to_ssa(function);\n    convert_reads_to_ssa(function);\n\n    function.control_flow.to_graphviz();\n}\n\npub fn convert_functions_to_ssa(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function_or_prototype) in functions {\n        match function_or_prototype {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e convert_function_to_ssa(function),\n        };\n    }\n}\n\nfn remove_ssa_from_function(function: \u0026mut symtab::Function) {\n    for block in \u0026mut function.control_flow.blocks.values_mut() {\n        let old_arguments = block.arguments.clone();\n        block.arguments.clear();\n        block.arguments = BTreeSet::\u003cir::OperandName\u003e::new();\n        for arg in old_arguments {\n            block.arguments.insert(arg.into_non_ssa());\n        }\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = None;\n            }\n\n            for write in statement.write_operand_names_mut() {\n                write.ssa_number = None;\n            }\n        }\n    }\n    function.control_flow.to_graphviz();\n}\n\npub fn remove_ssa_from_functions(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e remove_ssa_from_function(function),\n        };\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","symtab.rs"],"content":"use crate::midend::types::Type;\nuse std::collections::HashMap;\n\nuse serde::Serialize;\nuse std::fmt::Display;\n\nuse super::ir;\n\n#[derive(Clone, Debug, Serialize)]\npub struct Variable {\n    name: String,\n    mangled_name: Option\u003cString\u003e,\n    type_: Type,\n}\n\nimpl Display for Variable {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.type_, self.name)\n    }\n}\n\nimpl Variable {\n    pub fn new(name: String, type_: Type) -\u003e Self {\n        Variable {\n            name,\n            mangled_name: None,\n            type_,\n        }\n    }\n\n    pub fn add_mangled_name(\u0026mut self, scope_indices: \u0026Vec\u003cusize\u003e) {\n        let mut mangled_name = String::new();\n        for scope in scope_indices {\n            mangled_name.push_str(\u0026(scope.to_string() + \u0026String::from(\"_\")));\n        }\n        mangled_name.push_str(\u0026self.name.clone());\n\n        match \u0026self.mangled_name {\n            Some(current_name) =\u003e {\n                panic!(\n                \"Variable {} already has mangled name {}, can't add_mangled_name with new name {}\",\n                self.name,\n                current_name,\n                mangled_name)\n            }\n            None =\u003e self.mangled_name.replace(mangled_name),\n        };\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        match \u0026self.mangled_name {\n            Some(mangled_name) =\u003e mangled_name.clone(),\n            None =\u003e self.name.clone(),\n        }\n    }\n\n    pub fn type_(\u0026self) -\u003e \u0026Type {\n        \u0026self.type_\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Scope {\n    subscope_indices: Vec\u003cusize\u003e,\n    variables: HashMap\u003cString, Variable\u003e,\n    subscopes: Vec\u003cScope\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Scope {\n            subscope_indices: Vec::new(),\n            variables: HashMap::new(),\n            subscopes: Vec::new(),\n        }\n    }\n\n    pub fn insert_variable(\u0026mut self, mut variable: Variable) {\n        variable.add_mangled_name(\u0026self.subscope_indices);\n        self.variables.insert(variable.name.clone(), variable);\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Variable\u003e {\n        self.variables.get(name)\n    }\n\n    pub fn insert_subscope(\u0026mut self, subscope: Scope) {\n        self.subscopes.push(subscope);\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FunctionPrototype {\n    pub name: String,\n    pub arguments: Vec\u003cVariable\u003e,\n    pub return_type: Option\u003cType\u003e,\n}\n\nimpl Display for FunctionPrototype {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arguments_string = String::new();\n        for argument in \u0026self.arguments {\n            if arguments_string.len() \u003e 0 {\n                arguments_string = format!(\"{}, {}\", arguments_string, argument);\n            } else {\n                arguments_string = format!(\"{}\", argument);\n            }\n        }\n        match \u0026self.return_type {\n            Some(return_type) =\u003e write!(\n                f,\n                \"fun {}({}) -\u003e {}\",\n                self.name, arguments_string, return_type\n            ),\n            None =\u003e write!(f, \"fun {}({})\", self.name, arguments_string),\n        }\n    }\n}\n\nimpl FunctionPrototype {\n    pub fn new(name: String, arguments: Vec\u003cVariable\u003e, return_type: Option\u003cType\u003e) -\u003e Self {\n        FunctionPrototype {\n            name,\n            arguments,\n            return_type,\n        }\n    }\n\n    pub fn create_argument_scope(\u0026mut self) -\u003e Scope {\n        let mut arg_names: Vec\u003cString\u003e = Vec::new();\n        let mut argument_scope = Scope::new();\n        for arg in \u0026self.arguments {\n            arg_names.push(arg.name.clone());\n            argument_scope.insert_variable(arg.clone())\n        }\n\n        argument_scope\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Function {\n    pub prototype: FunctionPrototype,\n    pub scope: Scope,\n    pub control_flow: ir::ControlFlow,\n}\n\nimpl Function {\n    pub fn new(prototype: FunctionPrototype, scope: Scope, control_flow: ir::ControlFlow) -\u003e Self {\n        Function {\n            prototype,\n            scope,\n            control_flow,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        self.prototype.name.clone()\n    }\n}\n\n#[derive(Debug, Serialize)]\npub enum FunctionOrPrototype {\n    Function(Function),\n    Prototype(FunctionPrototype),\n}\n\n#[derive(Debug, Serialize)]\npub struct SymbolTable {\n    pub global_scope: Scope,\n    pub functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        SymbolTable {\n            global_scope: Scope::new(),\n            functions: HashMap::new(),\n        }\n    }\n\n    pub fn assign_program_points(\u0026mut self) {\n        // TODO: re-enable this when SSA implemented\n        // for function in self.functions.values_mut() {\n        //     match function {\n        //         FunctionOrPrototype::Function(f) =\u003e {\n        //             f.control_flow_mut().assign_program_points();\n        //             let mut reaching_defs = ReachingDefs::new(f.control_flow());\n        //             reaching_defs.analyze();\n        //             reaching_defs.print();\n        //         }\n        //         FunctionOrPrototype::Prototype(_) =\u003e {}\n        //     }\n        // }\n    }\n\n    pub fn print_ir(\u0026self) {\n        for function in self.functions.values() {\n            match function {\n                FunctionOrPrototype::Function(f) =\u003e {\n                    println!(\"{}\", f.prototype);\n                }\n                FunctionOrPrototype::Prototype(_) =\u003e {}\n            }\n        }\n    }\n\n    pub fn insert_function(\u0026mut self, function: Function) {\n        self.functions\n            .insert(function.name(), FunctionOrPrototype::Function(function));\n    }\n\n    pub fn insert_function_prototype(\u0026mut self, prototype: FunctionPrototype) {\n        self.functions.insert(\n            prototype.name.clone(),\n            FunctionOrPrototype::Prototype(prototype),\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":71},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","types.rs"],"content":"use serde::Serialize;\nuse std::fmt::Display;\n\n// #[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize)]\n// pub struct BasicTypeInfo {\n//     pointer_level: usize,\n// }\n\n// impl Display for BasicTypeInfo {\n//     fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n//         let mut pointer_string = String::new();\n//         for _ in 0..self.pointer_level {\n//             pointer_string.push('*');\n//         }\n//         write!(f, \"{}\", pointer_string)\n//     }\n// }\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize, serde::Deserialize)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\nimpl Display for Mutability {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Mutability::Mutable =\u003e write!(f, \"mut\"),\n            Mutability::Immutable =\u003e std::fmt::Result::Ok(()),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug, Serialize, serde::Deserialize)]\npub enum Type {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Reference(Mutability, Box\u003cType\u003e),\n    Pointer(Mutability, Box\u003cType\u003e),\n}\n\nimpl Display for Type {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Reference(mutability, to) =\u003e write!(f, \"\u0026{} {}\", mutability, to),\n            Self::Pointer(mutability, to) =\u003e write!(f, \"*{} {}\", mutability, to),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":16}]};
        var previousData = {"files":[{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","mod.rs"],"content":"mod regalloc;\n\nuse crate::midend::*;\n\npub fn generate_code_for_function(function: \u0026mut symtab::Function) {\n    println!(\"generate code for {}\", function.prototype);\n    regalloc::allocate_registers(\u0026function.scope, \u0026function.control_flow);\n}\n\npub fn generate_code(mut symbol_table: symtab::SymbolTable) {\n    for (_, member) in \u0026mut symbol_table.functions {\n        match member {\n            symtab::FunctionOrPrototype::Function(f) =\u003e generate_code_for_function(f),\n            symtab::FunctionOrPrototype::Prototype(p) =\u003e println!(\"{}\", p),\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","block_depths.rs"],"content":"use std::{\n    collections::{BTreeMap, VecDeque},\n    usize,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\nstruct BlockDepthMetadata\u003c'a\u003e {\n    depths: BTreeMap\u003cusize, usize\u003e,\n    control_flow: \u0026'a ir::ControlFlow,\n    unknown_predecessors_worklist: VecDeque\u003cusize\u003e,\n}\nimpl\u003c'a\u003e BlockDepthMetadata\u003c'a\u003e {\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            depths: BTreeMap::new(),\n            control_flow,\n            unknown_predecessors_worklist: VecDeque::new(),\n        }\n    }\n\n    fn set_block_depth(\u0026mut self, block_label: usize, depth: usize) {\n        self.depths.insert(block_label, depth);\n    }\n\n    fn max_of_predecessors(\u0026mut self, block_label: usize) -\u003e usize {\n        let mut max = usize::MIN;\n\n        for predecessor_label in \u0026self.control_flow.block_for_label(\u0026block_label).predecessors {\n            let predecessor_depth = match self.depths.get(predecessor_label) {\n                Some(depth) =\u003e *depth,\n                None =\u003e {\n                    self.unknown_predecessors_worklist\n                        .push_back(*predecessor_label);\n                    usize::MIN\n                }\n            };\n\n            max = usize::max(predecessor_depth, max);\n        }\n\n        max\n    }\n\n    fn visit(\u0026mut self, block_label: usize) {\n        let max_predecessor_depth = self.max_of_predecessors(block_label);\n        self.set_block_depth(block_label, max_predecessor_depth + 1);\n    }\n}\n\npub fn find_block_depths(control_flow: \u0026ir::ControlFlow) -\u003e BTreeMap\u003cusize, usize\u003e {\n    let mut metadata = BlockDepthMetadata::new(control_flow);\n\n    for (label, _) in control_flow.blocks_postorder() {\n        metadata.visit(label);\n    }\n\n    while let Some(unvisited) = metadata.unknown_predecessors_worklist.pop_front() {\n        metadata.visit(unvisited);\n    }\n\n    metadata.depths\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","lifetime.rs"],"content":"use std::{\n    cmp::Ordering,\n    collections::{BTreeMap, HashMap},\n    fmt,\n};\n\nuse crate::midend;\n\nuse super::program_point::ProgramPoint;\n\n#[derive(Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]\npub struct Lifetime {\n    pub name: midend::ir::OperandName,\n    pub start: usize,\n    pub end: usize,\n    pub n_reads: usize,\n    pub n_writes: usize,\n}\n\nimpl Lifetime {\n    pub fn new(name: midend::ir::OperandName) -\u003e Self {\n        Lifetime {\n            name: name,\n            start: usize::MAX,\n            end: usize::MIN,\n            n_reads: 0,\n            n_writes: 0,\n        }\n    }\n\n    fn update_range(\u0026mut self, potential_range_limit: \u0026usize) {\n        if *potential_range_limit \u003c self.start {\n            self.start = *potential_range_limit;\n        }\n        if self.end \u003c *potential_range_limit {\n            self.end = *potential_range_limit;\n        }\n    }\n\n    pub fn record_read(\u0026mut self, at_index: \u0026usize) {\n        self.n_reads += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn record_write(\u0026mut self, at_index: \u0026usize) {\n        self.n_writes += 1;\n        self.update_range(at_index);\n    }\n\n    pub fn live_at(\u0026self, at_index: \u0026usize) -\u003e bool {\n        (self.start \u003c= *at_index) \u0026\u0026 (self.end \u003e= *at_index)\n    }\n}\n\nimpl std::fmt::Display for Lifetime {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{}: {}-{}]\", self.name, self.start, self.end)\n    }\n}\n\npub struct LifetimeSet {\n    pub lifetimes: HashMap\u003cmidend::ir::OperandName, Lifetime\u003e,\n}\n\nimpl LifetimeSet {\n    fn new() -\u003e Self {\n        LifetimeSet {\n            lifetimes: HashMap::\u003cmidend::ir::OperandName, Lifetime\u003e::new(),\n        }\n    }\n\n    pub fn from_block(block: \u0026midend::ir::BasicBlock) -\u003e Self {\n        let mut lifetimes = Self::new();\n\n        for (index, line) in block.statements.iter().enumerate() {\n            for read_operand in line.read_operand_names() {\n                lifetimes.record_read_at_index(read_operand, \u0026index);\n            }\n\n            for write_operand in line.write_operand_names() {\n                lifetimes.record_write_at_index(write_operand, \u0026index);\n            }\n        }\n\n        lifetimes\n    }\n\n    fn lookup_or_create_lifetime_by_name(\n        \u0026mut self,\n        name: \u0026midend::ir::OperandName,\n    ) -\u003e \u0026mut Lifetime {\n        if !self.lifetimes.contains_key(name) {\n            self.lifetimes\n                .insert(name.clone(), Lifetime::new(name.clone()));\n        }\n\n        self.lifetimes.get_mut(name).unwrap()\n    }\n\n    pub fn record_read_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_read(index);\n    }\n\n    pub fn record_write_at_index(\u0026mut self, operand: \u0026midend::ir::OperandName, index: \u0026usize) {\n        self.lookup_or_create_lifetime_by_name(operand)\n            .record_write(index);\n    }\n\n    pub fn values(\n        \u0026self,\n    ) -\u003e std::collections::hash_map::Values\u003c'_, midend::ir::OperandName, Lifetime\u003e {\n        self.lifetimes.values()\n    }\n\n    pub fn print_numerical(\u0026self) {\n        for lifetime in self.lifetimes.values() {\n            println!(\n                \"{:\u003e20}: [{}-{}]\",\n                lifetime.name, lifetime.start, lifetime.end\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::{backend::regalloc::program_point::ProgramPoint, midend};\n\n    use super::Lifetime;\n\n    #[test]\n    fn test_lifetime_range() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        dummy_lifetime.record_read(\u00261);\n\n        assert!(dummy_lifetime.start == 1);\n        assert!(dummy_lifetime.start == dummy_lifetime.end);\n\n        dummy_lifetime.record_write(\u00260);\n\n        assert!(dummy_lifetime.start == 0);\n        assert!(dummy_lifetime.end == 1);\n    }\n\n    #[test]\n    fn test_lifetime_format() {\n        let mut dummy_lifetime =\n            Lifetime::new(midend::ir::OperandName::new_basic(\"my_variable\".into()));\n\n        let start_point = 2;\n        let end_point = 4;\n\n        dummy_lifetime.record_write(\u0026start_point);\n        dummy_lifetime.record_write(\u0026end_point);\n\n        assert_eq!(\n            format!(\"{}\", dummy_lifetime),\n            format!(\"[my_variable: {}-{}]\", start_point, end_point)\n        );\n    }\n\n    #[test]\n    fn test_lifetime_live_at() {\n        let mut dummy_lifetime = Lifetime::new(midend::ir::OperandName::new_basic(\"dummy\".into()));\n\n        assert!(!dummy_lifetime.live_at(\u00260));\n        dummy_lifetime.record_write(\u00260);\n        dummy_lifetime.record_write(\u00265);\n\n        for index in 0..5 {\n            assert!(dummy_lifetime.live_at(\u0026index));\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":11}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":44},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","mod.rs"],"content":"use std::collections::{BTreeMap, BTreeSet};\n\nuse block_depths::*;\nuse lifetime::{Lifetime, LifetimeSet};\nuse program_point::ProgramPoint;\n\nuse crate::midend::{self, ir::ControlFlow, symtab};\n\nmod block_depths;\nmod lifetime;\nmod program_point;\n\nfn record_interference_graph(\n    graph: \u0026mut BTreeMap\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e,\n    lifetime_a: \u0026midend::ir::OperandName,\n    lifetime_b: \u0026midend::ir::OperandName,\n) {\n    graph\n        .entry(lifetime_a.clone())\n        .or_default()\n        .insert(lifetime_b.clone());\n}\n\npub fn allocate_registers(_scope: \u0026symtab::Scope, control_flow: \u0026ControlFlow) {\n    println!(\"Allocate registers for scope\");\n\n    // let depths = find_block_depths(control_flow);\n\n    let mut graph = BTreeMap::\u003cmidend::ir::OperandName, BTreeSet\u003cmidend::ir::OperandName\u003e\u003e::new();\n\n    for (_, block) in \u0026control_flow.blocks {\n        let block_lifetimes = LifetimeSet::from_block(block);\n\n        for index in 0..block.statements.len() {\n            let mut first_iter = block_lifetimes.lifetimes.iter();\n\n            while let Some((first_name, first_lt)) = first_iter.next() {\n                if first_lt.live_at(\u0026index) {\n                    let mut second_iter = first_iter.clone();\n                    while let Some((second_name, second_lt)) = second_iter.next() {\n                        if second_lt.live_at(\u0026index) {\n                            record_interference_graph(\u0026mut graph, first_name, second_name);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","mitch","substratum","rust-rewrite","src","backend","regalloc","program_point.rs"],"content":"use core::fmt;\nuse std::cmp::Ordering;\n\nuse serde::Serialize;\n\n#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Serialize, Hash)]\npub struct ProgramPoint {\n    pub depth: usize, // depth in the DFS traversal of control flow\n    pub index: usize, // index within a basic block\n}\n\nimpl ProgramPoint {\n    pub fn default() -\u003e Self {\n        Self::new(0, 0)\n    }\n\n    pub fn new(depth: usize, index: usize) -\u003e Self {\n        ProgramPoint { depth, index }\n    }\n}\n\nimpl std::fmt::Display for ProgramPoint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:\u003e2x}:{:\u003c2x}\", self.depth, self.index)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::backend::regalloc::program_point::ProgramPoint;\n\n    #[test]\n    fn test_default() {\n        let default_point = ProgramPoint::default();\n\n        assert_eq!(default_point.depth, 0);\n        assert_eq!(default_point.index, 0);\n    }\n\n    #[test]\n    fn test_partial_ord_eq() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.partial_cmp(\u0026point_2), Some(Ordering::Greater));\n        assert_eq!(point_1.partial_cmp(\u0026point_3), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_ord() {\n        let point_1 = ProgramPoint::new(1, 1);\n        let point_2 = ProgramPoint::new(1, 0);\n        let point_3 = ProgramPoint::new(1, 1);\n\n        assert_eq!(point_1.cmp(\u0026point_2), Ordering::Greater);\n        assert_eq!(point_1.cmp(\u0026point_3), Ordering::Equal);\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":7}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","ast.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend};\nuse std::fmt::Display;\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum TranslationUnit {\n    FunctionDeclaration(FunctionDeclarationTree),\n    FunctionDefinition(FunctionDefinitionTree),\n}\n\nimpl Display for TranslationUnit {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::FunctionDeclaration(function_declaration) =\u003e {\n                write!(f, \"Function Declaration: {}\", function_declaration)\n            }\n            Self::FunctionDefinition(function_definition) =\u003e {\n                write!(f, \"Function Definition: {}\", function_definition)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TranslationUnitTree {\n    pub loc: SourceLoc,\n    pub contents: TranslationUnit,\n}\nimpl Display for TranslationUnitTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Translation Unit: {}\", self.contents)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub arguments: Vec\u003cVariableDeclarationTree\u003e,\n    pub return_type: Option\u003cTypenameTree\u003e,\n}\nimpl Display for FunctionDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arg_string = String::from(\"\");\n        for argument in \u0026self.arguments {\n            arg_string.push_str(format!(\"{}\\n\", argument).as_str());\n        }\n\n        match \u0026self.return_type {\n            Some(typename_tree) =\u003e write!(\n                f,\n                \"Function Declaration: {}({})-\u003e{}\",\n                self.name, arg_string, typename_tree\n            ),\n            None =\u003e write!(f, \"Function Declaration: {}({})\", self.name, arg_string),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct FunctionDefinitionTree {\n    pub prototype: FunctionDeclarationTree,\n    pub body: CompoundStatementTree,\n}\nimpl Display for FunctionDefinitionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Function Definition: {}, {}\", self.prototype, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct CompoundStatementTree {\n    pub loc: SourceLoc,\n    pub statements: Vec\u003cStatementTree\u003e,\n}\nimpl Display for CompoundStatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut statement_string = String::from(\"\");\n        for statement in \u0026self.statements {\n            statement_string.push_str(format!(\"{}\\n\", statement).as_str());\n        }\n        write!(f, \"Compound Statement: {}\", statement_string)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct IfStatementTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub true_block: CompoundStatementTree,\n    pub false_block: Option\u003cCompoundStatementTree\u003e,\n}\nimpl Display for IfStatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self.false_block {\n            Some(false_block) =\u003e write!(\n                f,\n                \"if {}\\n\\t{{{}}} else {{{}}}\",\n                self.condition, self.true_block, false_block\n            ),\n            None =\u003e write!(f, \"if {}\\n\\t{{{}}}\", self.condition, self.true_block),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct WhileLoopTree {\n    pub loc: SourceLoc,\n    pub condition: ExpressionTree,\n    pub body: CompoundStatementTree,\n}\nimpl Display for WhileLoopTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"while ({}) {}\", self.condition, self.body)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Statement {\n    VariableDeclaration(VariableDeclarationTree),\n    Assignment(AssignmentTree),\n    IfStatement(IfStatementTree),\n    WhileLoop(WhileLoopTree),\n}\n\nimpl Display for Statement {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::VariableDeclaration(variable_declaration) =\u003e {\n                write!(f, \"{}\", variable_declaration)\n            }\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{}\", assignment)\n            }\n            Self::IfStatement(if_statement) =\u003e {\n                write!(f, \"{}\", if_statement)\n            }\n            Self::WhileLoop(while_loop) =\u003e {\n                write!(f, \"{}\", while_loop)\n            }\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct StatementTree {\n    pub loc: SourceLoc,\n    pub statement: Statement,\n}\nimpl Display for StatementTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.statement)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct VariableDeclarationTree {\n    pub loc: SourceLoc,\n    pub name: String,\n    pub typename: TypenameTree,\n}\nimpl Display for VariableDeclarationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}: {}\", self.name, self.typename)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct AssignmentTree {\n    pub loc: SourceLoc,\n    pub identifier: String,\n    pub value: ExpressionTree,\n}\nimpl Display for AssignmentTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} = {}\", self.identifier, self.value)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ArithmeticDualOperands {\n    pub e1: Box\u003cExpressionTree\u003e,\n    pub e2: Box\u003cExpressionTree\u003e,\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ArithmeticOperationTree {\n    Add(ArithmeticDualOperands),\n    Subtract(ArithmeticDualOperands),\n    Multiply(ArithmeticDualOperands),\n    Divide(ArithmeticDualOperands),\n}\nimpl Display for ArithmeticOperationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e write!(f, \"({} + {})\", operands.e1, operands.e2),\n            Self::Subtract(operands) =\u003e write!(f, \"({} - {})\", operands.e1, operands.e2),\n            Self::Multiply(operands) =\u003e write!(f, \"({} * {})\", operands.e1, operands.e2),\n            Self::Divide(operands) =\u003e write!(f, \"({} / {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum ComparisonOperationTree {\n    LThan(ArithmeticDualOperands),\n    GThan(ArithmeticDualOperands),\n    LThanE(ArithmeticDualOperands),\n    GThanE(ArithmeticDualOperands),\n    Equals(ArithmeticDualOperands),\n    NotEquals(ArithmeticDualOperands),\n}\nimpl Display for ComparisonOperationTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::LThan(operands) =\u003e write!(f, \"({} \u003c {})\", operands.e1, operands.e2),\n            Self::GThan(operands) =\u003e write!(f, \"({} \u003e {})\", operands.e1, operands.e2),\n            Self::LThanE(operands) =\u003e write!(f, \"({} \u003c= {})\", operands.e1, operands.e2),\n            Self::GThanE(operands) =\u003e write!(f, \"({} \u003e= {})\", operands.e1, operands.e2),\n            Self::Equals(operands) =\u003e write!(f, \"({} == {})\", operands.e1, operands.e2),\n            Self::NotEquals(operands) =\u003e write!(f, \"({} != {})\", operands.e1, operands.e2),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub enum Expression {\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Arithmetic(ArithmeticOperationTree),\n    Comparison(ComparisonOperationTree),\n}\nimpl Display for Expression {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Identifier(identifier) =\u003e write!(f, \"{}\", identifier),\n            Self::UnsignedDecimalConstant(constant) =\u003e write!(f, \"{}\", constant),\n            Self::Arithmetic(operation) =\u003e write!(f, \"{}\", operation),\n            Self::Comparison(operation) =\u003e write!(f, \"{}\", operation),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct ExpressionTree {\n    pub loc: SourceLoc,\n    pub expression: Expression,\n}\nimpl Display for ExpressionTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.expression)\n    }\n}\n\n#[derive(Debug, PartialEq, serde::Serialize, serde::Deserialize)]\npub struct TypenameTree {\n    pub loc: SourceLoc,\n    pub type_: midend::types::Type,\n}\n\nimpl Display for TypenameTree {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.type_)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":19}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":5}},{"line":127,"address":[],"length":0,"stats":{"Line":5}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":5}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":25}},{"line":194,"address":[],"length":0,"stats":{"Line":25}},{"line":195,"address":[],"length":0,"stats":{"Line":14}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":197,"address":[],"length":0,"stats":{"Line":5}},{"line":198,"address":[],"length":0,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":214,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":73}},{"line":234,"address":[],"length":0,"stats":{"Line":73}},{"line":235,"address":[],"length":0,"stats":{"Line":15}},{"line":236,"address":[],"length":0,"stats":{"Line":30}},{"line":237,"address":[],"length":0,"stats":{"Line":25}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":73}},{"line":250,"address":[],"length":0,"stats":{"Line":73}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":1}}],"covered":42,"coverable":72},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","integration_tests.rs"],"content":"use crate::frontend::lexer::Lexer;\n\nuse super::token::Token;\n\nfn assert_single_tokenization(input_str: \u0026str, expected_token: Token) {\n    println!(\n        \"Assert single tokenization against {} == {}\",\n        input_str, expected_token\n    );\n    let result = Lexer::new(String::from(input_str).chars()).lex_all();\n    assert_eq!(result, vec! {expected_token, Token::Eof});\n}\n\n#[test]\nfn tokenize_l_curly() {\n    assert_single_tokenization(\"{\", Token::LCurly);\n}\n\n#[test]\nfn tokenize_r_curly() {\n    assert_single_tokenization(\"}\", Token::RCurly);\n}\n\n#[test]\nfn tokenize_identifier() {\n    assert_single_tokenization(\"abc\", Token::Identifier(String::from(\"abc\")));\n    assert_single_tokenization(\"abc123\", Token::Identifier(String::from(\"abc123\")));\n    assert_single_tokenization(\"abc123def\", Token::Identifier(String::from(\"abc123def\")));\n    assert_single_tokenization(\n        \"unsignedOrSomething_123\",\n        Token::Identifier(String::from(\"unsignedOrSomething_123\")),\n    );\n    assert_single_tokenization(\n        \"u16_named_fred\",\n        Token::Identifier(String::from(\"u16_named_fred\")),\n    );\n}\n\n#[test]\nfn tokenize_unsigned_decimal_constant() {\n    assert_single_tokenization(\"123\", Token::UnsignedDecimalConstant(123));\n    assert_single_tokenization(\n        \u0026usize::MAX.to_string(),\n        Token::UnsignedDecimalConstant(usize::MAX),\n    );\n    assert_single_tokenization(\n        \u0026usize::MIN.to_string(),\n        Token::UnsignedDecimalConstant(usize::MIN),\n    );\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":10}},{"line":6,"address":[],"length":0,"stats":{"Line":10}},{"line":7,"address":[],"length":0,"stats":{"Line":10}},{"line":8,"address":[],"length":0,"stats":{"Line":10}},{"line":10,"address":[],"length":0,"stats":{"Line":10}},{"line":11,"address":[],"length":0,"stats":{"Line":10}}],"covered":6,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","mod.rs"],"content":"use token::Token;\n\nuse super::sourceloc::SourceLoc;\n\nmod integration_tests;\nmod tests;\npub mod token;\n\npub struct Lexer\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    cur_line: usize,\n    cur_col: usize,\n    current_char: Option\u003cchar\u003e,\n    current_token: Option\u003cToken\u003e,\n    input: I,\n}\n\nimpl\u003cI\u003e Lexer\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    fn peek_char(\u0026self) -\u003e Option\u003cchar\u003e {\n        self.current_char\n    }\n\n    fn advance_char(\u0026mut self) {\n        if let Some(consumed) = self.current_char {\n            if consumed == '\\n' {\n                self.cur_line += 1;\n                self.cur_col = 1;\n            } else {\n                self.cur_col += 1;\n            }\n        }\n        self.current_char = self.input.next();\n    }\n\n    fn invalid_char(\u0026self, char: char) {\n        panic!(\"Invalid character '{}' at {}\", char, self.current_loc());\n    }\n\n    fn from_iterator(iterator: I) -\u003e Self {\n        Self {\n            cur_line: 1,\n            cur_col: 1,\n            current_char: None,\n            current_token: None,\n            input: iterator,\n        }\n    }\n\n    pub fn new(input: I) -\u003e Self {\n        let mut created = Self::from_iterator(input);\n        created.advance_char();\n        created.next();\n        return created;\n    }\n\n    fn match_kw_or_ident(\u0026mut self) -\u003e Token {\n        let mut identifier = String::new();\n\n        while let Some(c) = self.peek_char() {\n            if c.is_alphanumeric() || c == '_' {\n                identifier.push(c);\n                self.advance_char();\n            } else {\n                break;\n            }\n        }\n        match identifier.as_str() {\n            \"u8\" =\u003e Token::U8,\n            \"u16\" =\u003e Token::U16,\n            \"u32\" =\u003e Token::U32,\n            \"u64\" =\u003e Token::U64,\n            \"i8\" =\u003e Token::I8,\n            \"i16\" =\u003e Token::I16,\n            \"i32\" =\u003e Token::I32,\n            \"i64\" =\u003e Token::I64,\n            \"fun\" =\u003e Token::Fun,\n            \"if\" =\u003e Token::If,\n            \"else\" =\u003e Token::Else,\n            \"while\" =\u003e Token::While,\n            \"pub\" =\u003e Token::Pub,\n            \"struct\" =\u003e Token::Struct,\n            _ =\u003e Token::Identifier(identifier),\n        }\n    }\n\n    pub fn peek(\u0026self) -\u003e Token {\n        self.current_token.clone().unwrap_or(Token::Eof)\n    }\n\n    pub fn current_loc(\u0026self) -\u003e SourceLoc {\n        SourceLoc::new(self.cur_line, self.cur_col)\n    }\n\n    fn match_next_char_for_token_or(\n        \u0026mut self,\n        expected: char,\n        tok_true: Token,\n        tok_false: Token,\n    ) -\u003e Token {\n        match self.peek_char() {\n            None =\u003e tok_false,\n            Some(char) =\u003e {\n                if char == expected {\n                    self.advance_char();\n                    tok_true\n                } else {\n                    tok_false\n                }\n            }\n        }\n    }\n\n    fn lex(\u0026mut self) -\u003e Token {\n        while self.peek_char().is_some() \u0026\u0026 self.peek_char().unwrap().is_whitespace() {\n            self.advance_char();\n        }\n\n        let token = if let Some(char) = self.peek_char() {\n            match char {\n                '{' =\u003e {\n                    self.advance_char();\n                    Token::LCurly\n                }\n                '}' =\u003e {\n                    self.advance_char();\n                    Token::RCurly\n                }\n                '(' =\u003e {\n                    self.advance_char();\n                    Token::LParen\n                }\n                ')' =\u003e {\n                    self.advance_char();\n                    Token::RParen\n                }\n                '+' =\u003e {\n                    self.advance_char();\n                    Token::Plus\n                }\n                '-' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('\u003e', Token::Arrow, Token::Minus)\n                }\n                '*' =\u003e {\n                    self.advance_char();\n                    Token::Star\n                }\n                '/' =\u003e {\n                    self.advance_char();\n                    Token::FSlash\n                }\n                '\u003e' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::GThanE, Token::GThan)\n                }\n                '\u003c' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::LThanE, Token::LThan)\n                }\n                '!' =\u003e {\n                    self.advance_char();\n                    match self.peek_char() {\n                        None =\u003e {\n                            self.invalid_char('!');\n                            Token::Eof\n                        }\n                        Some(char) =\u003e {\n                            if char == '=' {\n                                self.advance_char();\n                                Token::NotEquals\n                            } else {\n                                self.invalid_char('!');\n                                Token::Eof\n                            }\n                        }\n                    }\n                }\n                '=' =\u003e {\n                    self.advance_char();\n                    self.match_next_char_for_token_or('=', Token::Equals, Token::Assign)\n                }\n                ',' =\u003e {\n                    self.advance_char();\n                    Token::Comma\n                }\n                ';' =\u003e {\n                    self.advance_char();\n                    Token::Semicolon\n                }\n                ':' =\u003e {\n                    self.advance_char();\n                    Token::Colon\n                }\n                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' =\u003e {\n                    let mut constant_string = String::new();\n                    while self.peek_char().is_some() {\n                        let char: char = self.peek_char().unwrap();\n                        if char.is_numeric() {\n                            self.advance_char();\n                            constant_string.push(char);\n                        } else {\n                            break;\n                        }\n                    }\n                    Token::UnsignedDecimalConstant(\n                        usize::from_str_radix(\u0026constant_string, 10)\n                            .expect(\"Couldn't convert unsigned decimal constant\"),\n                    )\n                }\n                _ =\u003e self.match_kw_or_ident(),\n            }\n        } else {\n            Token::Eof\n        };\n        token\n    }\n\n    pub fn next(\u0026mut self) -\u003e Token {\n        let next_token = self.lex();\n        self.current_token.replace(next_token).unwrap_or(Token::Eof)\n    }\n\n    pub fn lex_all(\u0026mut self) -\u003e Vec\u003cToken\u003e {\n        let mut tokens: Vec\u003cToken\u003e = Vec::new();\n        loop {\n            let next_token = self.next();\n            match next_token {\n                Token::Eof =\u003e {\n                    tokens.push(next_token);\n                    break;\n                }\n                _ =\u003e {\n                    tokens.push(next_token);\n                }\n            }\n        }\n\n        tokens\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":1979}},{"line":25,"address":[],"length":0,"stats":{"Line":1979}},{"line":28,"address":[],"length":0,"stats":{"Line":1020}},{"line":29,"address":[],"length":0,"stats":{"Line":1897}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":872}},{"line":37,"address":[],"length":0,"stats":{"Line":1020}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":144}},{"line":54,"address":[],"length":0,"stats":{"Line":72}},{"line":55,"address":[],"length":0,"stats":{"Line":72}},{"line":56,"address":[],"length":0,"stats":{"Line":72}},{"line":57,"address":[],"length":0,"stats":{"Line":72}},{"line":58,"address":[],"length":0,"stats":{"Line":72}},{"line":61,"address":[],"length":0,"stats":{"Line":130}},{"line":62,"address":[],"length":0,"stats":{"Line":130}},{"line":64,"address":[],"length":0,"stats":{"Line":1273}},{"line":65,"address":[],"length":0,"stats":{"Line":610}},{"line":66,"address":[],"length":0,"stats":{"Line":556}},{"line":67,"address":[],"length":0,"stats":{"Line":556}},{"line":69,"address":[],"length":0,"stats":{"Line":31}},{"line":72,"address":[],"length":0,"stats":{"Line":130}},{"line":73,"address":[],"length":0,"stats":{"Line":133}},{"line":74,"address":[],"length":0,"stats":{"Line":129}},{"line":75,"address":[],"length":0,"stats":{"Line":127}},{"line":76,"address":[],"length":0,"stats":{"Line":125}},{"line":77,"address":[],"length":0,"stats":{"Line":123}},{"line":78,"address":[],"length":0,"stats":{"Line":121}},{"line":79,"address":[],"length":0,"stats":{"Line":119}},{"line":80,"address":[],"length":0,"stats":{"Line":117}},{"line":81,"address":[],"length":0,"stats":{"Line":115}},{"line":82,"address":[],"length":0,"stats":{"Line":115}},{"line":83,"address":[],"length":0,"stats":{"Line":110}},{"line":84,"address":[],"length":0,"stats":{"Line":107}},{"line":85,"address":[],"length":0,"stats":{"Line":103}},{"line":86,"address":[],"length":0,"stats":{"Line":99}},{"line":90,"address":[],"length":0,"stats":{"Line":238}},{"line":91,"address":[],"length":0,"stats":{"Line":238}},{"line":94,"address":[],"length":0,"stats":{"Line":97}},{"line":95,"address":[],"length":0,"stats":{"Line":97}},{"line":98,"address":[],"length":0,"stats":{"Line":19}},{"line":104,"address":[],"length":0,"stats":{"Line":19}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":15}},{"line":107,"address":[],"length":0,"stats":{"Line":15}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":11}},{"line":117,"address":[],"length":0,"stats":{"Line":287}},{"line":118,"address":[],"length":0,"stats":{"Line":693}},{"line":119,"address":[],"length":0,"stats":{"Line":75}},{"line":122,"address":[],"length":0,"stats":{"Line":755}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":10}},{"line":138,"address":[],"length":0,"stats":{"Line":10}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":15}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":5}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":7}},{"line":184,"address":[],"length":0,"stats":{"Line":7}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":192,"address":[],"length":0,"stats":{"Line":6}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":50}},{"line":200,"address":[],"length":0,"stats":{"Line":141}},{"line":201,"address":[],"length":0,"stats":{"Line":131}},{"line":202,"address":[],"length":0,"stats":{"Line":222}},{"line":203,"address":[],"length":0,"stats":{"Line":91}},{"line":204,"address":[],"length":0,"stats":{"Line":91}},{"line":206,"address":[],"length":0,"stats":{"Line":40}},{"line":210,"address":[],"length":0,"stats":{"Line":50}},{"line":211,"address":[],"length":0,"stats":{"Line":50}},{"line":214,"address":[],"length":0,"stats":{"Line":45}},{"line":217,"address":[],"length":0,"stats":{"Line":106}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":287}},{"line":223,"address":[],"length":0,"stats":{"Line":287}},{"line":224,"address":[],"length":0,"stats":{"Line":287}},{"line":227,"address":[],"length":0,"stats":{"Line":42}},{"line":228,"address":[],"length":0,"stats":{"Line":42}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":84}},{"line":231,"address":[],"length":0,"stats":{"Line":84}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":42}},{"line":234,"address":[],"length":0,"stats":{"Line":42}},{"line":236,"address":[],"length":0,"stats":{"Line":42}},{"line":237,"address":[],"length":0,"stats":{"Line":42}},{"line":242,"address":[],"length":0,"stats":{"Line":42}}],"covered":110,"coverable":137},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","tests.rs"],"content":"use crate::frontend::lexer::Lexer;\nuse std::str::Chars;\n\nuse super::token::Token;\n\nfn lexer_from_string(string: \u0026str) -\u003e Lexer\u003cChars\u003e {\n    Lexer::\u003cChars\u003c'_\u003e\u003e::from_iterator(string.chars())\n}\n\n#[test]\nfn peek_none() {\n    let lexer = lexer_from_string(\"a\");\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn advance_char() {\n    let mut lexer = lexer_from_string(\"ab\");\n    assert!(lexer.peek_char() == None);\n    lexer.advance_char();\n    assert!(lexer.peek_char() == Some('a'));\n    lexer.advance_char();\n    assert!(lexer.peek_char() == Some('b'));\n}\n\n#[test]\nfn advance_to_end() {\n    let mut lexer = lexer_from_string(\"a\");\n    lexer.advance_char();\n    lexer.advance_char();\n    assert!(lexer.peek_char() == None);\n}\n\n#[test]\nfn test_loc_chars() {\n    let mut lexer = lexer_from_string(\"the quick brown\\nfox jumps\\nover the lazy\\ndog\\n\\n\");\n\n    let mut line_lengths = Vec::new();\n    let mut lines = 0;\n    let mut cols = 0;\n\n    lexer.advance_char();\n    while lexer.peek_char().is_some() {\n        let examined = lexer.peek_char().unwrap();\n        lexer.advance_char();\n        match examined {\n            '\\n' =\u003e {\n                line_lengths.push(cols);\n                cols = 0;\n                lines += 1;\n            }\n            _ =\u003e {\n                cols += 1;\n            }\n        }\n    }\n\n    assert!(lines == 5);\n    assert!(line_lengths == vec![15, 9, 13, 3, 0]);\n}\n\n// helper function - do some basic prefixing and suffixing\n// ensure keyword matching behaves as expected with alpha/num pre/suffixes\nfn kw_or_ident(string: \u0026str, expected_token: Token) {\n    let mut positive_match = lexer_from_string(string);\n    positive_match.advance_char();\n\n    let matched = positive_match.match_kw_or_ident();\n    assert!(matched == expected_token);\n\n    let prefix_alpha = \"a\".to_owned() + string;\n    let mut negative_match = lexer_from_string(\u0026prefix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(prefix_alpha));\n\n    let prefix_num = \"1\".to_owned() + string;\n    negative_match = Lexer::new(prefix_num.chars());\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() != expected_token);\n\n    let suffix_alpha = string.to_owned() + \"a\";\n    negative_match = lexer_from_string(\u0026suffix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(suffix_alpha));\n\n    let suffix_num = string.to_owned() + \"1\";\n    negative_match = lexer_from_string(\u0026suffix_num);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(suffix_num));\n}\n\n// test every token\n#[test]\nfn kw_u8() {\n    kw_or_ident(\"u8\", Token::U8);\n}\n\n#[test]\nfn kw_u16() {\n    kw_or_ident(\"u16\", Token::U16);\n}\n\n#[test]\nfn kw_u32() {\n    kw_or_ident(\"u32\", Token::U32);\n}\n\n#[test]\nfn kw_u64() {\n    kw_or_ident(\"u64\", Token::U64);\n}\n\n#[test]\nfn kw_i8() {\n    kw_or_ident(\"i8\", Token::I8);\n}\n\n#[test]\nfn kw_i16() {\n    kw_or_ident(\"i16\", Token::I16);\n}\n\n#[test]\nfn kw_i32() {\n    kw_or_ident(\"i32\", Token::I32);\n}\n\n#[test]\nfn kw_i64() {\n    kw_or_ident(\"i64\", Token::I64);\n}\n\n#[test]\nfn kw_fun() {\n    kw_or_ident(\"fun\", Token::Fun);\n}\n\n#[test]\nfn kw_if() {\n    kw_or_ident(\"if\", Token::If);\n}\n\n#[test]\nfn kw_else() {\n    kw_or_ident(\"else\", Token::Else);\n}\n\n#[test]\nfn kw_while() {\n    kw_or_ident(\"while\", Token::While);\n}\n\n#[test]\nfn kw_pub() {\n    kw_or_ident(\"pub\", Token::Pub);\n}\n\n#[test]\nfn kw_struct() {\n    kw_or_ident(\"struct\", Token::Struct);\n}\n\n\n#[test]\nfn ident() {\n    // test out some basic identifiers - such as ones containing keywords\n    kw_or_ident(\"foobar\", Token::Identifier(\"foobar\".to_owned()));\n    kw_or_ident(\"the_u8\", Token::Identifier(\"the_u8\".to_owned()));\n    kw_or_ident(\"big_if_true\", Token::Identifier(\"big_if_true\".to_owned()));\n\n    // make sure that we can correctly parse the end of identifiers\n    let space_after = \"space_after abcde\";\n    let space_after_ident = Token::Identifier(String::from(\"space_after\"));\n    let mut positive_match = lexer_from_string(space_after);\n    positive_match.advance_char();\n    assert!(positive_match.match_kw_or_ident() == space_after_ident);\n\n    let prefix_alpha = \"a\".to_owned() + space_after;\n    let mut negative_match = lexer_from_string(\u0026prefix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == Token::Identifier(String::from(\"aspace_after\")));\n\n    let prefix_num = \"1\".to_owned() + space_after;\n    negative_match = Lexer::new(prefix_num.chars());\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() != space_after_ident);\n\n    let suffix_alpha = space_after.to_owned() + \"a\";\n    negative_match = lexer_from_string(\u0026suffix_alpha);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == space_after_ident);\n\n    let suffix_num = space_after.to_owned() + \"1\";\n    negative_match = lexer_from_string(\u0026suffix_num);\n    negative_match.advance_char();\n    assert!(negative_match.match_kw_or_ident() == space_after_ident);\n}\n\n#[test]\nfn token_display_to_token() {\n    let tokens = vec![\n        Token::U8,\n        Token::U16,\n        Token::U32,\n        Token::U64,\n        Token::I8,\n        Token::I16,\n        Token::I32,\n        Token::I64,\n        Token::Plus,\n        Token::Minus,\n        Token::Star,\n        Token::FSlash,\n        Token::GThan,\n        Token::GThanE,\n        Token::LThan,\n        Token::LThanE,\n        Token::Equals,\n        Token::NotEquals,\n        Token::Assign,\n        Token::Fun,\n        Token::If,\n        Token::Else,\n        Token::While,\n        Token::Pub,\n        Token::Struct,\n        Token::LParen,\n        Token::RParen,\n        Token::Arrow,\n        Token::LCurly,\n        Token::RCurly,\n        Token::Comma,\n        Token::Semicolon,\n        Token::Colon,\n    ];\n\n    for token in tokens {\n        let lex_result = Lexer::new(format!(\"{}\", token).chars()).lex_all();\n        assert!(lex_result.len() == 2);\n        assert!(token == lex_result[0]);\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":72}},{"line":7,"address":[],"length":0,"stats":{"Line":72}},{"line":64,"address":[],"length":0,"stats":{"Line":16}},{"line":65,"address":[],"length":0,"stats":{"Line":16}},{"line":66,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[],"length":0,"stats":{"Line":16}},{"line":69,"address":[],"length":0,"stats":{"Line":16}},{"line":71,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":16}},{"line":73,"address":[],"length":0,"stats":{"Line":16}},{"line":74,"address":[],"length":0,"stats":{"Line":16}},{"line":76,"address":[],"length":0,"stats":{"Line":16}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":78,"address":[],"length":0,"stats":{"Line":16}},{"line":79,"address":[],"length":0,"stats":{"Line":16}},{"line":81,"address":[],"length":0,"stats":{"Line":16}},{"line":82,"address":[],"length":0,"stats":{"Line":16}},{"line":83,"address":[],"length":0,"stats":{"Line":16}},{"line":84,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":16}},{"line":87,"address":[],"length":0,"stats":{"Line":16}},{"line":88,"address":[],"length":0,"stats":{"Line":16}},{"line":89,"address":[],"length":0,"stats":{"Line":16}}],"covered":23,"coverable":23},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","lexer","token.rs"],"content":"use std::fmt::Display;\n\n#[derive(Clone, Debug)]\npub enum Token {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Plus,\n    Minus,\n    Star,\n    FSlash,\n    LThan,\n    GThan,\n    LThanE,\n    GThanE,\n    Equals,\n    NotEquals,\n    Assign,\n    Fun,\n    If,\n    Else,\n    Pub,\n    While,\n    Struct,\n    LParen,\n    RParen,\n    Arrow,\n    LCurly,\n    RCurly,\n    Comma,\n    Semicolon,\n    Colon,\n    Identifier(String),\n    UnsignedDecimalConstant(usize),\n    Eof,\n}\n\nimpl PartialEq for Token {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Token::U8, Token::U8) =\u003e true,\n            (Token::U16, Token::U16) =\u003e true,\n            (Token::U32, Token::U32) =\u003e true,\n            (Token::U64, Token::U64) =\u003e true,\n            (Token::I8, Token::I8) =\u003e true,\n            (Token::I16, Token::I16) =\u003e true,\n            (Token::I32, Token::I32) =\u003e true,\n            (Token::I64, Token::I64) =\u003e true,\n            (Token::Plus, Token::Plus) =\u003e true,\n            (Token::Minus, Token::Minus) =\u003e true,\n            (Token::Star, Token::Star) =\u003e true,\n            (Token::FSlash, Token::FSlash) =\u003e true,\n            (Token::LThan, Token::LThan) =\u003e true,\n            (Token::GThan, Token::GThan) =\u003e true,\n            (Token::LThanE, Token::LThanE) =\u003e true,\n            (Token::GThanE, Token::GThanE) =\u003e true,\n            (Token::Equals, Token::Equals) =\u003e true,\n            (Token::NotEquals, Token::NotEquals) =\u003e true,\n            (Token::Assign, Token::Assign) =\u003e true,\n            (Token::Fun, Token::Fun) =\u003e true,\n            (Token::If, Token::If) =\u003e true,\n            (Token::Else, Token::Else) =\u003e true,\n            (Token::While, Token::While) =\u003e true,\n            (Token::Pub, Token::Pub) =\u003e true,\n            (Token::Struct, Token::Struct) =\u003e true,\n            (Token::LParen, Token::LParen) =\u003e true,\n            (Token::RParen, Token::RParen) =\u003e true,\n            (Token::Arrow, Token::Arrow) =\u003e true,\n            (Token::LCurly, Token::LCurly) =\u003e true,\n            (Token::RCurly, Token::RCurly) =\u003e true,\n            (Token::Comma, Token::Comma) =\u003e true,\n            (Token::Semicolon, Token::Semicolon) =\u003e true,\n            (Token::Colon, Token::Colon) =\u003e true,\n            (Token::Identifier(a), Token::Identifier(b)) =\u003e a == b,\n            (Token::UnsignedDecimalConstant(a), Token::UnsignedDecimalConstant(b)) =\u003e a == b,\n            (Token::Eof, Token::Eof) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n}\n\nimpl Eq for Token {}\n\nimpl Display for Token {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Plus =\u003e write!(f, \"+\"),\n            Self::Minus =\u003e write!(f, \"-\"),\n            Self::Star =\u003e write!(f, \"*\"),\n            Self::FSlash =\u003e write!(f, \"/\"),\n            Self::GThan =\u003e write!(f, \"\u003e\"),\n            Self::GThanE =\u003e write!(f, \"\u003e=\"),\n            Self::LThan =\u003e write!(f, \"\u003c\"),\n            Self::LThanE =\u003e write!(f, \"\u003c=\"),\n            Self::Equals =\u003e write!(f, \"==\"),\n            Self::NotEquals =\u003e write!(f, \"!=\"),\n            Self::Assign =\u003e write!(f, \"=\"),\n            Self::Fun =\u003e write!(f, \"fun\"),\n            Self::If =\u003e write!(f, \"if\"),\n            Self::Else =\u003e write!(f, \"else\"),\n            Self::While =\u003e write!(f, \"while\"),\n            Self::Pub =\u003e write!(f, \"pub\"),\n            Self::Struct =\u003e write!(f, \"struct\"),\n            Self::LParen =\u003e write!(f, \"(\"),\n            Self::RParen =\u003e write!(f, \")\"),\n            Self::Arrow =\u003e write!(f, \"-\u003e\"),\n            Self::LCurly =\u003e write!(f, \"{{\"),\n            Self::RCurly =\u003e write!(f, \"}}\"),\n            Self::Comma =\u003e write!(f, \",\"),\n            Self::Semicolon =\u003e write!(f, \";\"),\n            Self::Colon =\u003e write!(f, \":\"),\n            Self::Identifier(string) =\u003e write!(f, \"Identifier({})\", string),\n            Self::UnsignedDecimalConstant(constant) =\u003e {\n                write!(f, \"UnsignedDecimalConstant({})\", constant)\n            }\n            Self::Eof =\u003e write!(f, \"EOF\"),\n        }\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":137}},{"line":44,"address":[],"length":0,"stats":{"Line":137}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":64}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":13}},{"line":88,"address":[],"length":0,"stats":{"Line":42}},{"line":89,"address":[],"length":0,"stats":{"Line":42}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":0}}],"covered":75,"coverable":76},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","mod.rs"],"content":"pub mod ast;\npub mod lexer;\npub mod parser;\npub mod sourceloc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","parser","mod.rs"],"content":"mod tests;\n\nuse crate::midend::{ir, types::Type};\n\nuse super::{\n    ast::*,\n    lexer::{token::Token, *},\n    sourceloc::SourceLoc,\n};\n\npub struct Parser\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    lexer: Lexer\u003cI\u003e,\n}\n\nimpl ir::BinaryOperations {\n    pub fn get_precedence(\u0026self) -\u003e usize {\n        match self {\n            Self::Add(_) =\u003e 1,\n            Self::Subtract(_) =\u003e 1,\n            Self::Multiply(_) =\u003e 2,\n            Self::Divide(_) =\u003e 2,\n            Self::LThan(_) =\u003e 3,\n            Self::GThan(_) =\u003e 3,\n            Self::LThanE(_) =\u003e 3,\n            Self::GThanE(_) =\u003e 3,\n            Self::Equals(_) =\u003e 4,\n            Self::NotEquals(_) =\u003e 4,\n        }\n    }\n\n    pub fn precedence_of_token(token: \u0026Token) -\u003e usize {\n        match token {\n            Token::Plus =\u003e 1,\n            Token::Minus =\u003e 1,\n            Token::Star =\u003e 2,\n            Token::FSlash =\u003e 2,\n            Token::LThan =\u003e 3,\n            Token::GThan =\u003e 3,\n            Token::LThanE =\u003e 3,\n            Token::GThanE =\u003e 3,\n            Token::Equals =\u003e 4,\n            Token::NotEquals =\u003e 4,\n            _ =\u003e {\n                panic!(\n                    \"Invalid token {} passed to BinaryOperations::precedence_of_token\",\n                    token\n                );\n            }\n        }\n    }\n}\n\nimpl\u003cI\u003e Parser\u003cI\u003e\nwhere\n    I: Iterator\u003cItem = char\u003e,\n{\n    pub fn new(lexer: Lexer\u003cI\u003e) -\u003e Self\n    where\n        I: Iterator\u003cItem = char\u003e,\n    {\n        Parser { lexer: lexer }\n    }\n\n    fn peek_token(\u0026self) -\u003e Token {\n        return self.lexer.peek();\n    }\n\n    fn next_token(\u0026mut self) -\u003e Token {\n        return self.lexer.next();\n    }\n\n    fn expect_token(\u0026mut self, t: Token) -\u003e Token {\n        if matches!(self.peek_token(), t) {\n            self.next_token()\n        } else {\n            panic!(\n                \"Expected token {} at {}, got token {} instead!\",\n                t,\n                self.lexer.current_loc(),\n                self.peek_token()\n            );\n        }\n    }\n\n    fn current_loc(\u0026self) -\u003e SourceLoc {\n        self.lexer.current_loc()\n    }\n\n    fn unexpected_token\u003cT\u003e(\u0026self) -\u003e T {\n        panic!(\n            \"Unexpected token {} at {}\",\n            self.peek_token(),\n            self.current_loc()\n        );\n    }\n\n    pub fn parse(\u0026mut self) -\u003e Vec\u003cTranslationUnitTree\u003e {\n        let mut translation_units = Vec::new();\n        while self.lexer.peek() != Token::Eof {\n            translation_units.push(self.parse_translation_unit());\n        }\n        translation_units\n    }\n\n    fn parse_translation_unit(\u0026mut self) -\u003e TranslationUnitTree {\n        match self.peek_token() {\n            Token::Fun =\u003e self.parse_function_declaration_or_definition(),\n            _ =\u003e self.unexpected_token::\u003cTranslationUnitTree\u003e(),\n        }\n    }\n\n    fn parse_function_declaration_or_definition(\u0026mut self) -\u003e TranslationUnitTree {\n        let function_declaration = self.parse_function_prototype();\n        match self.peek_token() {\n            Token::LCurly =\u003e TranslationUnitTree {\n                loc: function_declaration.loc,\n                contents: TranslationUnit::FunctionDefinition(FunctionDefinitionTree {\n                    prototype: function_declaration,\n                    body: self.parse_compound_statement(),\n                }),\n            },\n            _ =\u003e TranslationUnitTree {\n                loc: function_declaration.loc,\n                contents: TranslationUnit::FunctionDeclaration(function_declaration),\n            },\n        }\n    }\n\n    fn parse_compound_statement(\u0026mut self) -\u003e CompoundStatementTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::LCurly);\n        let mut statements: Vec\u003cStatementTree\u003e = Vec::new();\n        loop {\n            match self.peek_token() {\n                Token::RCurly =\u003e break,\n                _ =\u003e statements.push(self.parse_statement()),\n            }\n        }\n        self.expect_token(Token::RCurly);\n        CompoundStatementTree {\n            loc: start_loc,\n            statements: statements,\n        }\n    }\n\n    fn parse_statement(\u0026mut self) -\u003e StatementTree {\n        let statement_tree = StatementTree {\n            loc: self.current_loc(),\n            statement: match self.peek_token() {\n                Token::Identifier(identifier) =\u003e {\n                    self.next_token();\n                    let statement = match self.peek_token() {\n                        Token::Colon =\u003e Statement::VariableDeclaration(\n                            self.parse_variable_declaration(identifier),\n                        ),\n                        Token::Assign =\u003e Statement::Assignment(self.parse_assignment(identifier)),\n                        _ =\u003e self.unexpected_token(),\n                    };\n                    self.expect_token(Token::Semicolon);\n                    statement\n                }\n                Token::If =\u003e Statement::IfStatement(self.parse_if_statement()),\n                Token::While =\u003e Statement::WhileLoop(self.parse_while_loop()),\n                _ =\u003e self.unexpected_token(),\n            },\n        };\n        statement_tree\n    }\n\n    fn parse_if_statement(\u0026mut self) -\u003e IfStatementTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::If);\n\n        self.expect_token(Token::LParen);\n        let condition: ExpressionTree = self.parse_expression();\n        self.expect_token(Token::RParen);\n\n        let true_block = self.parse_compound_statement();\n        let false_block = match self.peek_token() {\n            Token::Else =\u003e {\n                self.expect_token(Token::Else);\n                Some(self.parse_compound_statement())\n            }\n            _ =\u003e None,\n        };\n\n        IfStatementTree {\n            loc: start_loc,\n            condition,\n            true_block,\n            false_block,\n        }\n    }\n\n    fn parse_while_loop(\u0026mut self) -\u003e WhileLoopTree {\n        let start_loc = self.current_loc();\n        self.expect_token(Token::While);\n\n        self.expect_token(Token::LParen);\n        let condition = self.parse_expression();\n        self.expect_token(Token::RParen);\n\n        let body = self.parse_compound_statement();\n\n        WhileLoopTree {\n            loc: start_loc,\n            condition,\n            body,\n        }\n    }\n\n    fn parse_assignment(\u0026mut self, identifier: String) -\u003e AssignmentTree {\n        let start_loc = self.current_loc();\n        let lhs = identifier;\n        self.expect_token(Token::Assign);\n        AssignmentTree {\n            loc: start_loc,\n            identifier: lhs,\n            value: self.parse_expression(),\n        }\n    }\n\n    fn parse_primary_expression(\u0026mut self) -\u003e ExpressionTree {\n        ExpressionTree {\n            loc: self.current_loc(),\n            expression: {\n                let primary_expression = match self.peek_token() {\n                    Token::Identifier(value) =\u003e {\n                        self.next_token();\n                        Expression::Identifier(value)\n                    }\n                    Token::UnsignedDecimalConstant(value) =\u003e {\n                        self.next_token();\n                        Expression::UnsignedDecimalConstant(value)\n                    }\n                    Token::LParen =\u003e {\n                        self.expect_token(Token::LParen);\n                        let expr = self.parse_expression();\n                        self.expect_token(Token::RParen);\n                        expr.expression\n                    } // TODO: don't duplciate ExpressionTree here\n                    _ =\u003e self.unexpected_token(),\n                };\n                primary_expression\n            },\n        }\n    }\n\n    fn token_is_operator_of_at_least_precedence(token: \u0026Token, precedence: usize) -\u003e bool {\n        match token {\n            Token::Plus\n            | Token::Minus\n            | Token::Star\n            | Token::FSlash\n            | Token::LThan\n            | Token::GThan\n            | Token::LThanE\n            | Token::GThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e ir::BinaryOperations::precedence_of_token(\u0026token) \u003e= precedence,\n            _ =\u003e false,\n        }\n    }\n\n    fn parse_expression_min_precedence(\n        \u0026mut self,\n        lhs: ExpressionTree,\n        min_precedence: usize,\n    ) -\u003e ExpressionTree {\n        let mut expr = lhs;\n        let start_loc = self.current_loc();\n        while Self::token_is_operator_of_at_least_precedence(\u0026self.peek_token(), min_precedence) {\n            let operation = self.next_token();\n            let mut rhs = self.parse_primary_expression();\n\n            while Self::token_is_operator_of_at_least_precedence(\n                \u0026self.peek_token(),\n                ir::BinaryOperations::precedence_of_token(\u0026operation),\n            ) {\n                rhs = self.parse_expression_min_precedence(\n                    rhs,\n                    ir::BinaryOperations::precedence_of_token(\u0026operation),\n                );\n            }\n\n            let operands = ArithmeticDualOperands {\n                e1: Box::new(expr),\n                e2: Box::new(rhs),\n            };\n            expr = ExpressionTree {\n                loc: start_loc,\n                expression: match operation {\n                    Token::Plus =\u003e Expression::Arithmetic(ArithmeticOperationTree::Add(operands)),\n                    Token::Minus =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Subtract(operands))\n                    }\n                    Token::Star =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Multiply(operands))\n                    }\n                    Token::FSlash =\u003e {\n                        Expression::Arithmetic(ArithmeticOperationTree::Divide(operands))\n                    }\n                    Token::LThan =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::LThan(operands))\n                    }\n                    Token::GThan =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::GThan(operands))\n                    }\n                    Token::LThanE =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::LThanE(operands))\n                    }\n                    Token::GThanE =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::GThanE(operands))\n                    }\n                    Token::Equals =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::Equals(operands))\n                    }\n                    Token::NotEquals =\u003e {\n                        Expression::Comparison(ComparisonOperationTree::NotEquals(operands))\n                    }\n                    _ =\u003e self.unexpected_token(),\n                },\n            };\n        }\n        expr\n    }\n\n    fn parse_expression(\u0026mut self) -\u003e ExpressionTree {\n        let lhs = self.parse_primary_expression();\n        match self.peek_token() {\n            Token::Plus | Token::Minus | Token::Star | Token::FSlash =\u003e {\n                self.parse_expression_min_precedence(lhs, 0)\n            }\n            Token::GThan\n            | Token::GThanE\n            | Token::LThan\n            | Token::LThanE\n            | Token::Equals\n            | Token::NotEquals =\u003e self.parse_expression_min_precedence(lhs, 0),\n            _ =\u003e lhs,\n        }\n    }\n\n    fn parse_function_prototype(\u0026mut self) -\u003e FunctionDeclarationTree {\n        let start_loc = self.current_loc();\n        // start with fun\n        self.expect_token(Token::Fun);\n        FunctionDeclarationTree {\n            // grab start location and name\n            loc: start_loc,\n            name: self.parse_identifier(),\n            arguments: {\n                self.expect_token(Token::LParen);\n                let mut arguments = Vec::\u003cVariableDeclarationTree\u003e::new();\n                loop {\n                    match self.peek_token() {\n                        // argument declaration\n                        Token::Identifier(identifier) =\u003e {\n                            self.next_token();\n                            arguments.push(self.parse_variable_declaration(identifier));\n                            match self.peek_token() {\n                                Token::Comma =\u003e self.next_token(), // expect another argument declaration after comma\n                                _ =\u003e break,                        // loop again for anything else\n                            };\n                        }\n                        Token::RParen =\u003e break, // done on rparen\n                        _ =\u003e self.unexpected_token(),\n                    }\n                }\n                // consume closing paren\n                self.expect_token(Token::RParen);\n                arguments\n            },\n            return_type: match self.peek_token() {\n                Token::Arrow =\u003e {\n                    self.next_token();\n                    Some(self.parse_typename())\n                }\n                _ =\u003e None,\n            },\n        }\n    }\n\n    fn parse_variable_declaration(\u0026mut self, name: String) -\u003e VariableDeclarationTree {\n        VariableDeclarationTree {\n            loc: self.current_loc(),\n            name,\n            typename: {\n                self.expect_token(Token::Colon);\n                self.parse_typename()\n            },\n        }\n    }\n\n    fn parse_typename(\u0026mut self) -\u003e TypenameTree {\n        TypenameTree {\n            loc: self.current_loc(),\n            type_: match self.peek_token() {\n                Token::U8 =\u003e {\n                    self.next_token();\n                    Type::U8\n                }\n                Token::U16 =\u003e {\n                    self.next_token();\n                    Type::U16\n                }\n                Token::U32 =\u003e {\n                    self.next_token();\n                    Type::U32\n                }\n                Token::U64 =\u003e {\n                    self.next_token();\n                    Type::U64\n                }\n                Token::I8 =\u003e {\n                    self.next_token();\n                    Type::I8\n                }\n                Token::I16 =\u003e {\n                    self.next_token();\n                    Type::I16\n                }\n                Token::I32 =\u003e {\n                    self.next_token();\n                    Type::I32\n                }\n                Token::I64 =\u003e {\n                    self.next_token();\n                    Type::I64\n                }\n                _ =\u003e self.unexpected_token(),\n            },\n        }\n    }\n\n    fn parse_identifier(\u0026mut self) -\u003e String {\n        match self.expect_token(Token::Identifier(String::from(\"\"))) {\n            Token::Identifier(value) =\u003e value,\n            _ =\u003e self.unexpected_token::\u003cString\u003e(),\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":78}},{"line":35,"address":[],"length":0,"stats":{"Line":78}},{"line":36,"address":[],"length":0,"stats":{"Line":40}},{"line":37,"address":[],"length":0,"stats":{"Line":9}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":13}},{"line":67,"address":[],"length":0,"stats":{"Line":238}},{"line":68,"address":[],"length":0,"stats":{"Line":238}},{"line":71,"address":[],"length":0,"stats":{"Line":131}},{"line":72,"address":[],"length":0,"stats":{"Line":131}},{"line":75,"address":[],"length":0,"stats":{"Line":52}},{"line":76,"address":[],"length":0,"stats":{"Line":52}},{"line":77,"address":[],"length":0,"stats":{"Line":52}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":97}},{"line":89,"address":[],"length":0,"stats":{"Line":97}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":9}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":5}},{"line":151,"address":[],"length":0,"stats":{"Line":5}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":170,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":5}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":226,"address":[],"length":0,"stats":{"Line":51}},{"line":228,"address":[],"length":0,"stats":{"Line":51}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":90}},{"line":253,"address":[],"length":0,"stats":{"Line":90}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":36}},{"line":264,"address":[],"length":0,"stats":{"Line":54}},{"line":268,"address":[],"length":0,"stats":{"Line":27}},{"line":273,"address":[],"length":0,"stats":{"Line":27}},{"line":274,"address":[],"length":0,"stats":{"Line":27}},{"line":275,"address":[],"length":0,"stats":{"Line":55}},{"line":276,"address":[],"length":0,"stats":{"Line":28}},{"line":277,"address":[],"length":0,"stats":{"Line":28}},{"line":279,"address":[],"length":0,"stats":{"Line":35}},{"line":280,"address":[],"length":0,"stats":{"Line":35}},{"line":281,"address":[],"length":0,"stats":{"Line":35}},{"line":283,"address":[],"length":0,"stats":{"Line":7}},{"line":284,"address":[],"length":0,"stats":{"Line":7}},{"line":285,"address":[],"length":0,"stats":{"Line":7}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":28}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":14}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":3}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":27}},{"line":331,"address":[],"length":0,"stats":{"Line":23}},{"line":332,"address":[],"length":0,"stats":{"Line":23}},{"line":333,"address":[],"length":0,"stats":{"Line":23}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":17}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":343,"address":[],"length":0,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":0}}],"covered":92,"coverable":182},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","parser","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::frontend::lexer::{token::Token, *};\n    use crate::Parser;\n    use std::str::Chars;\n\n    #[cfg(test)]\n    fn parser_from_string(input: \u0026str) -\u003e Parser\u003cChars\u003c'_\u003e\u003e {\n        Parser::new(Lexer::new(input.chars()))\n    }\n\n    /// Expressions\n    #[cfg(test)]\n    fn parse_and_print_expression(input: \u0026str) -\u003e String {\n        let mut parser = parser_from_string(input);\n        let expr_string = parser.parse_expression().to_string();\n        parser.expect_token(Token::Eof);\n        expr_string\n    }\n\n    #[test]\n    fn basic_expression() {\n        assert_eq!(\n            parse_and_print_expression(\"123 + 456 + 789\"),\n            \"(123 + (456 + 789))\"\n        );\n    }\n\n    #[test]\n    fn addition_and_multiplication() {\n        assert_eq!(\n            parse_and_print_expression(\"123 + 456 * 789\"),\n            \"(123 + (456 * 789))\"\n        );\n    }\n\n    #[test]\n    fn parentheses_override_precedence() {\n        assert_eq!(\n            parse_and_print_expression(\"(123 + 456) * 789\"),\n            \"((123 + 456) * 789)\"\n        );\n    }\n\n    #[test]\n    fn mixed_arithmetic_operations() {\n        assert_eq!(\n            parse_and_print_expression(\"1 + 2 * 3 - 4 / 5\"),\n            \"(1 + ((2 * 3) - (4 / 5)))\"\n        );\n    }\n\n    #[test]\n    fn nested_parentheses() {\n        assert_eq!(\n            parse_and_print_expression(\"((1 + 2) * (3 - 4)) / 5\"),\n            \"(((1 + 2) * (3 - 4)) / 5)\"\n        );\n    }\n\n    #[test]\n    fn single_number() {\n        assert_eq!(parse_and_print_expression(\"42\"), \"42\");\n    }\n\n    #[test]\n    fn single_number_parenthesized() {\n        assert_eq!(parse_and_print_expression(\"(42)\"), \"42\");\n    }\n\n    #[test]\n    fn multiple_additions() {\n        assert_eq!(parse_and_print_expression(\"1 + 2 + 3\"), \"(1 + (2 + 3))\");\n    }\n\n    #[test]\n    fn complex_arithmetic_expression() {\n        assert_eq!(\n            parse_and_print_expression(\"3 + 4 * 2 / (1 - 5)\"),\n            \"(3 + (4 * (2 / (1 - 5))))\"\n        );\n    }\n\n    /// variable declarations\n    fn parse_and_print_variable_declaration(input: \u0026str) -\u003e String {\n        let mut parser = parser_from_string(input);\n        let ident = parser.parse_identifier();\n        let expr_string = parser.parse_variable_declaration(ident).to_string();\n        parser.expect_token(Token::Eof);\n        expr_string\n    }\n\n    #[test]\n    fn u8_declaration() {\n        assert_eq!(parse_and_print_variable_declaration(\"abc: u8\"), \"abc: u8\");\n    }\n\n    #[test]\n    fn if_statement() {\n        let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;}\");\n        assert_eq!(\n            format!(\"{}\", p.parse_if_statement()),\n            \"if (a \u003e b)\n\\t{Compound Statement: a = (a + b)\n}\"\n        );\n    }\n\n    #[test]\n    fn if_else_statement() {\n        let mut p = parser_from_string(\"if(a \u003e b) {a = a + b;} else {b = b + a;}\");\n        assert_eq!(\n            format!(\"{}\", p.parse_if_statement()),\n            \"if (a \u003e b)\n\\t{Compound Statement: a = (a + b)\n} else {Compound Statement: b = (b + a)\n}\"\n        );\n    }\n    // assert_eq!(p.parse_if_statement(), IfStatementTree {loc: SouceLoc::new(0, 0),\n    // condition: Expression {loc: SourceLoc::new(0, 5), expression: Expression::Comparison(ComparisonOperationTree::GThan(ArithmeticDualOperands {Box::new(ExpressionTree {loc: SourceLoc::new()})}))}});}}\n\n    #[test]\n    fn while_loop() {\n        let mut p =\n            parser_from_string(\"while (a \u003e b) {b = b + a; count = count + 1;} a = a + count;\");\n        assert_eq!(\n            format!(\"{}\", p.parse_while_loop()),\n            \"while ((a \u003e b)) Compound Statement: b = (b + a)\ncount = (count + 1)\n\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","frontend","sourceloc.rs"],"content":"use std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct SourceLoc {\n    line: usize,\n    col: usize,\n}\n\nimpl SourceLoc {\n    pub fn none() -\u003e Self {\n        SourceLoc { line: 0, col: 0 }\n    }\n\n    pub fn new(line: usize, col: usize) -\u003e Self {\n        SourceLoc { line, col }\n    }\n}\n\nimpl Display for SourceLoc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}:{}\", self.line, self.col)\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":14}},{"line":16,"address":[],"length":0,"stats":{"Line":119}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","Users","mitch","substratum","rust-rewrite","src","hashmap_ooo_iter.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::hash::Hash;\n\nfn check_key_order\u003cK, V\u003e(map: \u0026HashMap\u003cK, V\u003e, key_order: \u0026Vec\u003cK\u003e)\nwhere\n    K: Eq + Hash,\n{\n    let mut seen_keys = HashSet::\u003c\u0026K\u003e::new();\n    for key in key_order {\n        assert!(\n            map.contains_key(key),\n            \"All keys in key ordering for out-of-order HashMap iterator must be present in map\"\n        );\n        assert!(\n            !seen_keys.contains(key),\n            \"Duplicate key seen in key ordering for out-of-order HashMap iterator\",\n        );\n        seen_keys.insert(key);\n    }\n\n    assert!(\n        seen_keys.len() == map.len(),\n        \"Missing key(s) from key ordering for out-of-order HashMap iterator. All keys must be included\"\n    );\n}\n\n// the iterator itself only needs to own Key, \u0026Value pairs\npub struct HashMapOOOIter\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a V)\u003e,\n}\n\n// iteration is simply popping from the references vec\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIter\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIter\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // allocate the vector with its full capacity from the get-go\n        let mut references = Vec::\u003c(K, \u0026'a V)\u003e::with_capacity(map.len());\n        // grab values for each key, moving each key into the references vector along with its corresponding value reference\n        for key in key_order.into_iter().rev() {\n            let value_ref: \u0026V = map.get(\u0026key).unwrap();\n            references.push((key, value_ref));\n        }\n\n        HashMapOOOIter { references }\n    }\n}\n\npub struct HashMapOOOIterMut\u003c'a, K, V\u003e {\n    references: Vec\u003c(K, \u0026'a mut V)\u003e,\n}\n\nimpl\u003c'a, K, V\u003e Iterator for HashMapOOOIterMut\u003c'a, K, V\u003e {\n    type Item = (K, \u0026'a mut V);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.references.pop()\n    }\n}\n\nimpl\u003c'a, K, V\u003e HashMapOOOIterMut\u003c'a, K, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn new(map: \u0026'a mut HashMap\u003cK, V\u003e, key_order: Vec\u003cK\u003e) -\u003e Self {\n        check_key_order(map, \u0026key_order);\n\n        // same as for HashMapOOOIter but with additional reference manipulation\n        let mut references = Vec::\u003c(K, \u0026'a mut V)\u003e::with_capacity(map.len());\n        for key in key_order.into_iter().rev() {\n            // get our value reference as normal\n            let value: \u0026V = map.get(\u0026key).unwrap();\n            // create a pointer from the reference, and cast it to a mutable pointer\n            let pointer: *const V = std::ptr::from_ref(value);\n            let mut_pointer: *mut V = pointer as *mut V;\n            // since we have exactly one instance of every key in the map per check_key_order()\n            let value_mut: \u0026mut V = unsafe {\n                // trust that we can .as_mut() the pointer into a mutable reference\n                mut_pointer.as_mut()\n            }\n            .unwrap();\n            references.push((key, value_mut));\n        }\n\n        HashMapOOOIterMut { references }\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","mitch","substratum","rust-rewrite","src","main.rs"],"content":"mod backend;\nmod frontend;\nmod midend;\n\nmod hashmap_ooo_iter;\n\nuse backend::generate_code;\nuse frontend::{lexer::Lexer, parser::Parser};\n\nconst FIB_FUN: \u0026str = \"fun fib(u8 n) -\u003e u64\n{\n    u64 result;\n    result = 0;\n    if (n \u003e 0) {\n        if(n == 0) {\n            result = 0;\n        } else {\n         result = 1;\n        }\n    } else {\n        result = (n - 1) - (n - 2);\n    }\n}\";\n\nconst WHILE_LOOP: \u0026str = \"fun down_to_zero(u16 input)\n{\n    input = input;\n    while(input \u003e 0) {\n        input = input - 1;\n    }\n\n    input = input + 1;\n}\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH: \u0026str = \"\nfun while_with_nested_branch(a: u8, b: u16, c: u32) {\n    counter: u8;\n    counter = 0;\n    while (a \u003c b) {\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            counter = counter - 1;\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst WHILE_LOOP_WITH_NESTED_BRANCH_NO_ARGS: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    while (a \u003c b) {\n        u8 counter;\n        if (c \u003e 22) {\n            a = a + b;\n        } else {\n            b = b - 1;\n        }\n    }\n}\n\";\n\nconst NESTED_WHILE_LOOPS: \u0026str = \"\nfun while_with_nested_branch(u8 a, u16 b, u32 c) {\n    while (a \u003c b) {\n        u8 counter;\n        counter = 0;\n        if (c \u003e 22) {\n            counter = counter + 1;\n        } else {\n            while (counter \u003e 0) {\n            counter = counter - 1;\n            }\n        }\n    }\n\n    a = a + b;\n}\n\";\n\nconst SSA_EXAMPLE: \u0026str = \"\nfun while_with_nested_branch() {\n    u8 a; u16 b; u32 c;\n\n    a = 0;\n    b = 1;\n    c = 2;\n    \n    a = b + c;\n    b = a + c;\n    if (a \u003e b) {\n    c = c + 1;\n    } else {\n     c = 1;}\n    c = c + 1;\n    c = c + 1;\n}\";\n\nfn main() {\n    println!(\"Hello, world!\");\n    let parsed = String::from(WHILE_LOOP_WITH_NESTED_BRANCH);\n    let mut parser = Parser::new(Lexer::new(parsed.chars()));\n    let program = parser.parse();\n\n    for t in \u0026program {\n        println!(\"{}\", t);\n    }\n\n    let mut symtab = midend::symbol_table_from_program(program);\n\n    // println!(\"{}\", serde_json::to_string_pretty(\u0026symtab).unwrap());\n    symtab.print_ir();\n\n    symtab.assign_program_points();\n\n    generate_code(symtab);\n}\n","traces":[{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","block_args.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct BlockArgs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for BlockArgs\u003c'a\u003e {\n    fn f_transfer(\n        facts: \u0026mut idfa_base::BlockFacts\u003cFact\u003e,\n        _to_transfer: BTreeSet\u003cFact\u003e,\n    ) -\u003e BTreeSet\u003cFact\u003e {\n        facts.gen_facts.clone()\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut super::Facts\u003cFact\u003e) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    if !block_facts.kill_facts.contains(read) {\n                        block_facts.gen_facts.insert(read.clone());\n                    }\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.kill_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(mut a: BTreeSet\u003cFact\u003e, b: \u0026BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e super::Facts\u003cFact\u003e {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","block_depths.rs"],"content":"\npub struct BlockDepths\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","idfa_base.rs"],"content":"use std::{\n    collections::{BTreeSet, HashMap},\n    fmt::Display,\n};\n\nuse crate::midend::ir;\n\n#[derive(Debug)]\npub enum IdfaAnalysisDirection {\n    Forward,\n    Backward,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct BlockFacts\u003cT\u003e {\n    pub in_facts: BTreeSet\u003cT\u003e,\n    pub out_facts: BTreeSet\u003cT\u003e,\n    pub gen_facts: BTreeSet\u003cT\u003e,\n    pub kill_facts: BTreeSet\u003cT\u003e,\n}\n\nimpl\u003cT\u003e BlockFacts\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        BlockFacts {\n            in_facts: BTreeSet::\u003cT\u003e::new(),\n            out_facts: BTreeSet::\u003cT\u003e::new(),\n            gen_facts: BTreeSet::\u003cT\u003e::new(),\n            kill_facts: BTreeSet::\u003cT\u003e::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    facts: HashMap\u003cusize, BlockFacts\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Facts\u003cT\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub fn new(n_blocks: usize) -\u003e Self {\n        Self {\n            facts: HashMap::new(),\n        }\n    }\n    pub fn for_label(\u0026self, label: usize) -\u003e \u0026BlockFacts\u003cT\u003e {\n        self.facts.get(\u0026label).unwrap()\n    }\n\n    pub fn for_label_mut(\u0026mut self, label: usize) -\u003e \u0026mut BlockFacts\u003cT\u003e {\n        self.facts.entry(label).or_insert(BlockFacts::\u003cT\u003e::new())\n    }\n}\n\npub trait IdfaImplementor\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    fn f_transfer(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e);\n    fn f_meet(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e;\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self;\n    fn reanalyze(\u0026mut self);\n    fn take_facts(self) -\u003e Facts\u003cT\u003e;\n    fn facts(\u0026self) -\u003e \u0026Facts\u003cT\u003e;\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts\u003cT\u003e;\n}\n\n#[derive(Debug)]\npub struct Idfa\u003c'a, T\u003e\nwhere\n    T: Display + PartialEq,\n{\n    pub control_flow: \u0026'a ir::ControlFlow,\n    direction: IdfaAnalysisDirection,\n    last_facts: Facts\u003cT\u003e,\n    pub facts: Facts\u003cT\u003e,\n    f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n    f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n}\n\nimpl\u003c'a, T\u003e Idfa\u003c'a, T\u003e\nwhere\n    Facts\u003cT\u003e: PartialEq,\n    T: std::fmt::Debug + Display + Clone + Ord,\n{\n    fn store_facts_as_last(\u0026mut self) {\n        self.last_facts = self.facts.clone();\n    }\n\n    fn reached_fixpoint(\u0026mut self) -\u003e bool {\n        self.facts == self.last_facts\n    }\n\n    fn analyze_block_forwards\u003c'b\u003e(\u0026mut self, block: \u0026ir::BasicBlock) {\n        let label = block.label;\n        let mut new_in_facts = BTreeSet::\u003cT\u003e::new();\n\n        for predecessor in \u0026block.predecessors {\n            new_in_facts =\n                (self.f_meet)(new_in_facts, \u0026self.facts.for_label(*predecessor).out_facts);\n        }\n\n        self.facts.for_label_mut(label).in_facts = new_in_facts.clone();\n        let transferred = (self.f_transfer)(self.facts.for_label_mut(label), new_in_facts);\n        self.facts.for_label_mut(label).out_facts = transferred;\n    }\n\n    fn analyze_forward(\u0026mut self) {\n        let mut first_iteration = true;\n        while !self.reached_fixpoint() || first_iteration {\n            first_iteration = false;\n            self.store_facts_as_last();\n\n            for (_, block) in \u0026self.control_flow.blocks {\n                self.analyze_block_forwards(block);\n            }\n        }\n    }\n\n    fn analyze_backward(\u0026mut self) {\n        // let mut first_iteration = true;\n        // while !self.reached_fixpoint() || first_iteration {\n        unimplemented!();\n        // first_iteration = false;\n        // self.store_facts_as_last();\n        // }\n    }\n\n    pub fn analyze(\u0026mut self) {\n        (self.f_find_gen_kills)(self.control_flow, \u0026mut self.facts);\n        match self.direction {\n            IdfaAnalysisDirection::Forward =\u003e {\n                self.analyze_forward();\n            }\n            IdfaAnalysisDirection::Backward =\u003e {\n                self.analyze_backward();\n            }\n        }\n    }\n\n    pub fn new(\n        control_flow: \u0026'a ir::ControlFlow,\n        direction: IdfaAnalysisDirection,\n        f_find_gen_kills: fn(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts\u003cT\u003e),\n        f_meet: fn(a: BTreeSet\u003cT\u003e, b: \u0026BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n        f_transfer: fn(facts: \u0026mut BlockFacts\u003cT\u003e, to_transfer: BTreeSet\u003cT\u003e) -\u003e BTreeSet\u003cT\u003e,\n    ) -\u003e Self {\n        let mut idfa = Self {\n            control_flow,\n            direction,\n            last_facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            facts: Facts::\u003cT\u003e::new(control_flow.blocks.len()),\n            f_find_gen_kills,\n            f_meet,\n            f_transfer,\n        };\n\n        idfa.analyze();\n\n        idfa\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","live_vars.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base::{self, IdfaImplementor};\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct LiveVars\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for LiveVars\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = facts.gen_facts.clone();\n\n        for fact in \u0026to_transfer {\n            if !facts.kill_facts.contains(fact) {\n                transferred.insert(fact.clone());\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","mod.rs"],"content":"pub mod block_args;\nmod idfa_base;\npub mod live_vars;\npub mod reaching_defs;\n\npub use block_args::BlockArgs;\npub use idfa_base::Facts;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","idfa","reaching_defs.rs"],"content":"use std::collections::BTreeSet;\n\nuse crate::midend::ir;\n\nuse super::idfa_base;\npub use super::idfa_base::IdfaImplementor;\n\npub type Fact = ir::OperandName;\npub type BlockFacts = idfa_base::BlockFacts\u003cFact\u003e;\npub type Facts = idfa_base::Facts\u003cFact\u003e;\n\npub struct ReachingDefs\u003c'a\u003e {\n    idfa: idfa_base::Idfa\u003c'a, Fact\u003e,\n}\n\nimpl\u003c'a\u003e IdfaImplementor\u003c'a, Fact\u003e for ReachingDefs\u003c'a\u003e {\n    fn f_transfer(facts: \u0026mut BlockFacts, to_transfer: BTreeSet\u003cFact\u003e) -\u003e BTreeSet\u003cFact\u003e {\n        let mut transferred = BTreeSet::\u003cFact\u003e::new();\n\n        for gen_fact in \u0026facts.gen_facts {\n            if !facts.kill_facts.contains(gen_fact) {\n                transferred.insert(gen_fact.clone());\n            }\n        }\n\n        for in_fact in \u0026facts.in_facts {\n            if !facts.kill_facts.contains(in_fact) {\n                transferred.insert(in_fact.clone());\n            }\n        }\n\n        for transfer_fact in to_transfer {\n            if !facts.kill_facts.contains(\u0026transfer_fact) {\n                transferred.insert(transfer_fact);\n            }\n        }\n\n        transferred\n    }\n\n    fn f_find_gen_kills(control_flow: \u0026'a ir::ControlFlow, facts: \u0026mut Facts) {\n        //TODO: need to be able to possibly act on function arguments for gen/kill\n        // e.g. reaching defs on function arguments\n\n        for (label, block) in \u0026control_flow.blocks {\n            let block_facts = facts.for_label_mut(*label);\n\n            for statement in \u0026block.statements {\n                for read in statement.read_operand_names() {\n                    block_facts.kill_facts.insert(read.clone());\n                }\n                for write in statement.write_operand_names() {\n                    block_facts.gen_facts.insert(write.clone());\n                }\n            }\n        }\n    }\n\n    fn f_meet(\n        mut a: std::collections::BTreeSet\u003cFact\u003e,\n        b: \u0026std::collections::BTreeSet\u003cFact\u003e,\n    ) -\u003e std::collections::BTreeSet\u003cFact\u003e {\n        for fact in b {\n            a.insert((*fact).clone());\n        }\n\n        a\n    }\n\n    fn new(control_flow: \u0026'a ir::ControlFlow) -\u003e Self {\n        Self {\n            idfa: idfa_base::Idfa::new(\n                control_flow,\n                idfa_base::IdfaAnalysisDirection::Forward,\n                Self::f_find_gen_kills,\n                Self::f_meet,\n                Self::f_transfer,\n            ),\n        }\n    }\n\n    fn reanalyze(\u0026mut self) {\n        self.idfa.analyze();\n    }\n\n    fn take_facts(self) -\u003e Facts {\n        self.idfa.facts\n    }\n\n    fn facts(\u0026self) -\u003e \u0026Facts {\n        \u0026self.idfa.facts\n    }\n\n    fn facts_mut(\u0026mut self) -\u003e \u0026mut Facts {\n        \u0026mut self.idfa.facts\n    }\n}\n\nimpl\u003c'a\u003e ReachingDefs\u003c'a\u003e\n// TODO: supertrait?\n{\n    pub fn print(\u0026self) {\n        for label in self.idfa.control_flow.blocks.keys() {\n            let facts = self.idfa.facts.for_label(*label);\n            println!(\"{}:\", label);\n\n            print!(\"\\tGEN:\");\n            for gen_fact in \u0026facts.gen_facts {\n                print!(\"{} \", gen_fact);\n            }\n            println!();\n\n            print!(\"\\tKILL:\");\n            for kill_fact in \u0026facts.kill_facts {\n                print!(\"{} \", kill_fact);\n            }\n            println!();\n\n            print!(\"\\tIN:\");\n            for in_fact in \u0026facts.in_facts {\n                print!(\"{} \", in_fact);\n            }\n            println!();\n\n            print!(\"\\tOUT:\");\n            for out_fact in \u0026facts.out_facts {\n                print!(\"{} \", out_fact);\n            }\n            println!();\n        }\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","control_flow.rs"],"content":"use crate::{\n    frontend::sourceloc::SourceLoc,\n    hashmap_ooo_iter::{HashMapOOOIter, HashMapOOOIterMut},\n};\n\nuse super::ir;\nuse serde::Serialize;\nuse std::{\n    collections::{HashMap, HashSet, VecDeque},\n    fmt::Debug,\n    usize,\n};\n\n/*\n    A ControlFlow represents the notion of ownership over basic blocks. At the end of linearization of a section of code,\n    all relevant basic blocks will be owned by a single control flow. During linearization control flows can branch\n    correspondingly with actual branches in the code, as they are linarized. Each branch gets its own control flow,\n    which owns only the blocks relevant to the contents of branch. When the linearization of each branch is complete,\n    its control flow is merged back to the one from which it was branched. The original brancher then takes ownership\n    of all blocks of the branchee.\n*/\n\n#[derive(Debug, Serialize)]\npub struct ControlFlow {\n    pub blocks: HashMap\u003cusize, ir::BasicBlock\u003e,\n    pub max_block: usize,\n}\n\nimpl ControlFlow {\n    pub fn new() -\u003e Self {\n        let mut starter_blocks = HashMap::\u003cusize, ir::BasicBlock\u003e::new();\n        starter_blocks.insert(0, ir::BasicBlock::new(0));\n        starter_blocks.insert(1, ir::BasicBlock::new(1));\n        ControlFlow {\n            blocks: starter_blocks,\n            max_block: 1,\n        }\n    }\n\n    pub fn block_for_label(\u0026self, label: \u0026usize) -\u003e \u0026ir::BasicBlock {\n        self.blocks.get(label).unwrap()\n    }\n\n    fn block_mut_for_label(\u0026mut self, label: usize) -\u003e \u0026mut ir::BasicBlock {\n        self.blocks\n            .entry(label)\n            .or_insert(ir::BasicBlock::new(label))\n    }\n\n    pub fn next_block(\u0026mut self) -\u003e usize {\n        self.max_block += 1;\n        self.max_block\n    }\n\n    // appends the given statement to the block with the label provided\n    // returns: (Option\u003cusize\u003e, Option\u003cusize\u003e) referring to (if the statement is a branch):\n    // block targeted by branch\n    // block control flow ends up in if the branch is not taken (conditional branches only)\n    // retrurns an option to a reference to the field containing the destination label of the false jump\n    // iff the statement was a conditional jump which forced the end of the block\n    pub fn append_statement_to_block(\n        \u0026mut self,\n        statement: ir::IrLine,\n        label: usize,\n    ) -\u003e (Option\u003cusize\u003e, Option\u003cusize\u003e) {\n        self.append_statement_to_block_raw(statement.clone(), label);\n\n        match \u0026statement.operation {\n            ir::Operations::Jump(jump) =\u003e {\n                let target = jump.destination_block;\n                match \u0026jump.condition {\n                    ir::JumpCondition::Unconditional =\u003e (Some(target), None),\n                    _ =\u003e {\n                        let false_label = self.next_block();\n                        let block_exit = ir::IrLine::new_jump(\n                            SourceLoc::none(),\n                            false_label,\n                            ir::JumpCondition::Unconditional,\n                        );\n                        self.append_statement_to_block_raw(block_exit, label);\n                        (Some(target), Some(false_label))\n                    }\n                }\n            }\n            _ =\u003e (None, None),\n        }\n    }\n\n    fn append_statement_to_block_raw(\u0026mut self, statement: ir::IrLine, label: usize) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(operands) =\u003e {\n                let target_block = operands.destination_block;\n\n                self.block_mut_for_label(target_block)\n                    .predecessors\n                    .insert(label);\n                self.block_mut_for_label(label)\n                    .successors\n                    .insert(target_block);\n            }\n            _ =\u003e {}\n        };\n\n        self.block_mut_for_label(label).statements.push(statement);\n    }\n\n    pub fn to_graphviz(\u0026self) {\n        print!(\"digraph {{fontname=\\\"consolas\\\"; node[shape=box; fontname=\\\"consolas\\\"; nojustify=true]; splines=ortho;\");\n        for block in self.blocks.values() {\n            let mut block_arg_string = String::new();\n            for arg in \u0026block.arguments {\n                block_arg_string += \u0026format!(\"{} \", arg);\n            }\n\n            let mut block_string =\n                String::from(format!(\"Block {}({})\\n\", block.label, block_arg_string));\n            for statement in \u0026block.statements {\n                let stmt_str = \u0026String::from(format!(\"{}\\\\l\", statement)).replace(\"\\\"\", \"\\\\\\\"\");\n                block_string += stmt_str;\n            }\n\n            println!(\"{}[label=\\\"{}\\\\l\\\"]; \", block.label, block_string);\n\n            for successor in \u0026block.successors {\n                print!(\"{}-\u003e{};\", block.label, successor);\n            }\n        }\n\n        println!(\"}}\");\n    }\n\n    pub fn replace_blocks\u003cT: IntoIterator\u003cItem = ir::BasicBlock\u003e\u003e(\u0026mut self, iter: T) {\n        let mut into = iter.into_iter();\n\n        while let Some(block) = into.next() {\n            self.max_block = usize::max(self.max_block, block.label);\n            self.blocks.insert(block.label, block);\n        }\n    }\n}\n\nstruct ControlFlowPostorder {\n    postorder_stack: VecDeque\u003cir::BasicBlock\u003e,\n}\n\nimpl Iterator for ControlFlowPostorder {\n    type Item = ir::BasicBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_front()\n    }\n}\n\nstruct ControlFlowIter\u003c'a\u003e {\n    postorder_stack: VecDeque\u003c\u0026'a ir::BasicBlock\u003e,\n}\n\nimpl\u003c'a\u003e Iterator for ControlFlowIter\u003c'a\u003e {\n    type Item = \u0026'a ir::BasicBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\npub struct ControlFlowIntoIter\u003cT\u003e {\n    postorder_stack: VecDeque\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for ControlFlowIntoIter\u003cT\u003e {\n    type Item = T;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        self.postorder_stack.pop_back()\n    }\n}\n\n// TODO: are the postorder and reverse postorder named opposite right now? Need to actually check this...\nimpl ControlFlow {\n    fn generate_postorder_stack(\u0026self) -\u003e Vec\u003cusize\u003e {\n        let mut postorder_stack = Vec::\u003cusize\u003e::new();\n        postorder_stack.clear();\n        let mut visited = HashSet::\u003cusize\u003e::new();\n\n        let mut dfs_stack = Vec::\u003cusize\u003e::new();\n        dfs_stack.push(0);\n\n        // go until done\n        while dfs_stack.len() \u003e 0 {\n            match dfs_stack.pop() {\n                Some(label) =\u003e {\n                    // only visit once\n                    if !visited.contains(\u0026label) {\n                        visited.insert(label);\n\n                        postorder_stack.push(label);\n\n                        for successor in \u0026self.block_for_label(\u0026label).successors {\n                            dfs_stack.push(*successor);\n                        }\n                    }\n                }\n                None =\u003e {}\n            }\n        }\n        postorder_stack\n    }\n\n    pub fn blocks_postorder(\u0026self) -\u003e HashMapOOOIter\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIter::new(\u0026self.blocks, postorder_stack)\n    }\n\n    pub fn blocks_postorder_mut(\u0026mut self) -\u003e HashMapOOOIterMut\u003cusize, ir::BasicBlock\u003e {\n        let postorder_stack = self.generate_postorder_stack();\n\n        HashMapOOOIterMut::new(\u0026mut self.blocks, postorder_stack)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::midend::ir::*;\n\n    #[test]\n    fn starter_blocks() {\n        let cf = ControlFlow::new();\n\n        assert!(cf.blocks.len() == 2);\n        assert!(cf.max_block == 1);\n    }\n\n    #[test]\n    fn get_block_for_label() {\n        let mut cf = ControlFlow::new();\n\n        assert_eq!(cf.block_for_label(\u00260).label, 0);\n\n        assert_eq!(cf.block_mut_for_label(0).label, 0);\n        assert_eq!(cf.block_mut_for_label(999).label, 999);\n    }\n\n    #[test]\n    fn append_statement_to_block() {\n        let mut cf = ControlFlow::new();\n\n        let assignment = IrLine::new_assignment(\n            SourceLoc::none(),\n            Operand::new_as_variable(\"dest\".into()),\n            Operand::new_as_variable(\"source\".into()),\n        );\n        assert_eq!(cf.append_statement_to_block(assignment, 0), (None, None));\n    }\n\n    #[test]\n    fn append_unconditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(SourceLoc::none(), 1, JumpCondition::Unconditional);\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), None));\n    }\n\n    #[test]\n    fn append_conditional_jump_to_block() {\n        let mut cf = ControlFlow::new();\n        let jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a\".into()),\n                b: Operand::new_as_variable(\"eq_b\".into()),\n            }),\n        );\n        assert_eq!(cf.append_statement_to_block(jump, 0), (Some(1), Some(2)));\n\n        let second_jump = IrLine::new_jump(\n            SourceLoc::none(),\n            1,\n            JumpCondition::Eq(ir::operands::DualSourceOperands {\n                a: Operand::new_as_variable(\"eq_a2\".into()),\n                b: Operand::new_as_variable(\"eq_b2\".into()),\n            }),\n        );\n        assert_eq!(\n            cf.append_statement_to_block(second_jump, 0),\n            (Some(1), Some(3))\n        );\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":17}},{"line":31,"address":[],"length":0,"stats":{"Line":17}},{"line":32,"address":[],"length":0,"stats":{"Line":17}},{"line":33,"address":[],"length":0,"stats":{"Line":17}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":40}},{"line":46,"address":[],"length":0,"stats":{"Line":40}},{"line":47,"address":[],"length":0,"stats":{"Line":40}},{"line":50,"address":[],"length":0,"stats":{"Line":22}},{"line":51,"address":[],"length":0,"stats":{"Line":22}},{"line":52,"address":[],"length":0,"stats":{"Line":22}},{"line":61,"address":[],"length":0,"stats":{"Line":11}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":68,"address":[],"length":0,"stats":{"Line":11}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":70,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":14}},{"line":90,"address":[],"length":0,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":12}},{"line":98,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":87},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","mod.rs"],"content":"pub mod control_flow;\npub mod operands;\npub mod operations;\nmod tests;\n\nuse std::collections::BTreeSet;\nuse std::fmt::Display;\n\nuse crate::frontend::sourceloc::SourceLoc;\nuse crate::midend::ir;\nuse serde::Serialize;\n\npub use control_flow::ControlFlow;\npub use operands::*;\npub use operations::*;\n\n#[derive(Debug, Serialize, Clone)]\npub struct IrLine {\n    pub loc: SourceLoc,\n    pub operation: Operations,\n}\n\nimpl Display for IrLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.operation)\n    }\n}\n\n#[derive(Clone, Debug, Serialize)]\npub struct BasicBlock {\n    pub label: usize,\n    pub statements: Vec\u003cir::IrLine\u003e,\n    pub arguments: BTreeSet\u003cir::OperandName\u003e,\n    pub successors: BTreeSet\u003cusize\u003e,\n    pub predecessors: BTreeSet\u003cusize\u003e,\n}\n\nimpl BasicBlock {\n    pub fn new(label: usize) -\u003e Self {\n        BasicBlock {\n            statements: Vec::new(),\n            label: label,\n            arguments: BTreeSet::new(),\n            successors: BTreeSet::\u003cusize\u003e::new(),\n            predecessors: BTreeSet::\u003cusize\u003e::new(),\n        }\n    }\n}\n\nimpl IrLine {\n    fn new(loc: SourceLoc, operation: Operations) -\u003e Self {\n        IrLine {\n            loc: loc,\n            operation: operation,\n        }\n    }\n\n    pub fn new_assignment(loc: SourceLoc, destination: Operand, source: Operand) -\u003e Self {\n        Self::new(loc, Operations::new_assignment(destination, source))\n    }\n\n    pub fn new_binary_op(loc: SourceLoc, op: BinaryOperations) -\u003e Self {\n        Self::new(loc, Operations::BinaryOperation(op))\n    }\n\n    pub fn new_jump(\n        loc: SourceLoc,\n        destination_block: usize,\n        condition: operands::JumpCondition,\n    ) -\u003e Self {\n        Self::new(loc, Operations::new_jump(destination_block, condition))\n    }\n\n    pub fn read_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e match \u0026source_dest.source.get_name() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026operation.raw_operands().sources;\n                match sources.a.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values() {\n                    operand_names.push(arg);\n                }\n            }\n        }\n        operand_names\n    }\n\n    pub fn read_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e match source_dest.source.get_name_mut() {\n                Some(name) =\u003e operand_names.push(name),\n                None =\u003e {}\n            },\n            Operations::BinaryOperation(operation) =\u003e {\n                let sources = \u0026mut operation.raw_operands_mut().sources;\n                match sources.a.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n                match sources.b.get_name_mut() {\n                    Some(name) =\u003e operand_names.push(name),\n                    None =\u003e {}\n                }\n            }\n            Operations::Jump(jump_operands) =\u003e {\n                match \u0026mut jump_operands.condition {\n                    JumpCondition::Unconditional =\u003e {}\n                    JumpCondition::Eq(condition_operands)\n                    | JumpCondition::NE(condition_operands)\n                    | JumpCondition::GT(condition_operands)\n                    | JumpCondition::LT(condition_operands)\n                    | JumpCondition::GE(condition_operands)\n                    | JumpCondition::LE(condition_operands) =\u003e {\n                        match condition_operands.a.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                        match condition_operands.b.get_name_mut() {\n                            Some(name) =\u003e operand_names.push(name),\n                            None =\u003e {}\n                        }\n                    }\n                };\n                for arg in jump_operands.block_args.values_mut() {\n                    operand_names.push(arg);\n                }\n            }\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names(\u0026self) -\u003e Vec\u003c\u0026OperandName\u003e {\n        let mut operand_names: Vec\u003c\u0026OperandName\u003e = Vec::new();\n        match \u0026self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operand_names.push(\u0026source_dest.destination.get_name().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands();\n                operand_names.push(\u0026arithmetic_operands.destination.get_name().unwrap());\n            }\n            Operations::Jump(_) =\u003e {}\n        }\n\n        operand_names\n    }\n\n    pub fn write_operand_names_mut(\u0026mut self) -\u003e Vec\u003c\u0026mut OperandName\u003e {\n        let mut operands: Vec\u003c\u0026mut OperandName\u003e = Vec::new();\n        match \u0026mut self.operation {\n            Operations::Assignment(source_dest) =\u003e {\n                operands.push(source_dest.destination.get_name_mut().unwrap())\n            }\n            Operations::BinaryOperation(operation) =\u003e {\n                let arithmetic_operands = operation.raw_operands_mut();\n                operands.push(arithmetic_operands.destination.get_name_mut().unwrap());\n            }\n            Operations::Jump(_) =\u003e {}\n        }\n\n        operands\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":74}},{"line":41,"address":[],"length":0,"stats":{"Line":74}},{"line":43,"address":[],"length":0,"stats":{"Line":74}},{"line":44,"address":[],"length":0,"stats":{"Line":74}},{"line":45,"address":[],"length":0,"stats":{"Line":74}},{"line":51,"address":[],"length":0,"stats":{"Line":33}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":71,"address":[],"length":0,"stats":{"Line":13}},{"line":74,"address":[],"length":0,"stats":{"Line":8}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":6}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":8}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":8}},{"line":121,"address":[],"length":0,"stats":{"Line":8}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":8}},{"line":166,"address":[],"length":0,"stats":{"Line":8}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":178,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":8}},{"line":182,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":8}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":194,"address":[],"length":0,"stats":{"Line":8}}],"covered":80,"coverable":96},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","operands.rs"],"content":"use std::fmt::Display;\n\nuse serde::Serialize;\n\nuse crate::midend::{linearizer, types::Type};\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub struct OperandName {\n    pub base_name: String,\n    pub ssa_number: Option\u003cusize\u003e,\n}\n\nimpl PartialEq for OperandName {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        (self.base_name == other.base_name) \u0026\u0026 (self.ssa_number == other.ssa_number)\n    }\n}\n\nimpl Eq for OperandName {}\n\nimpl PartialOrd for OperandName {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        Some(\n            self.base_name\n                .cmp(\u0026other.base_name)\n                .then(match self.ssa_number {\n                    Some(self_ssa_number) =\u003e match other.ssa_number {\n                        Some(other_ssa_number) =\u003e self_ssa_number.cmp(\u0026other_ssa_number),\n                        None =\u003e std::cmp::Ordering::Greater,\n                    },\n                    None =\u003e match other.ssa_number {\n                        Some(_) =\u003e std::cmp::Ordering::Less,\n                        None =\u003e std::cmp::Ordering::Equal,\n                    },\n                }),\n        )\n    }\n}\n\nimpl Ord for OperandName {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Display for OperandName {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self.ssa_number {\n            Some(number) =\u003e {\n                write!(f, \"{}.{}\", self.base_name, number)\n            }\n            None =\u003e write!(f, \"{}\", self.base_name),\n        }\n    }\n}\n\nimpl OperandName {\n    pub fn new_basic(base_name: String) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: None,\n        }\n    }\n\n    fn new_ssa(base_name: String, ssa_number: usize) -\u003e Self {\n        Self {\n            base_name,\n            ssa_number: Some(ssa_number),\n        }\n    }\n\n    pub fn into_non_ssa(mut self) -\u003e Self {\n        self.ssa_number = None;\n        self\n    }\n}\n\n#[derive(Clone, Debug, Serialize, Hash)]\npub enum Operand {\n    Variable(OperandName),\n    Temporary(OperandName),\n    UnsignedDecimalConstant(usize),\n}\n\nimpl Display for Operand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Variable(name) =\u003e {\n                // write!(f, \"[V {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::Temporary(name) =\u003e {\n                // write!(f, \"[T {}]\", name)\n                write!(f, \"{}\", name)\n            }\n            Self::UnsignedDecimalConstant(value) =\u003e {\n                // write!(f, \"[C {}]\", value)\n                write!(f, \"{}\", value)\n            }\n        }\n    }\n}\n\nimpl PartialEq for Operand {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.cmp(other) == std::cmp::Ordering::Equal\n    }\n}\n\nimpl Eq for Operand {}\n\nimpl PartialOrd for Operand {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e std::option::Option\u003cstd::cmp::Ordering\u003e {\n        match (self, other) {\n            (Operand::Variable(var_self), Operand::Variable(var_other)) =\u003e {\n                Some(var_self.cmp(var_other))\n            }\n            (Operand::Temporary(temp_self), Operand::Temporary(temp_other)) =\u003e {\n                Some(temp_self.cmp(temp_other))\n            }\n            (\n                Operand::UnsignedDecimalConstant(value_self),\n                Operand::UnsignedDecimalConstant(value_other),\n            ) =\u003e Some(value_self.cmp(value_other)),\n            (_, _) =\u003e None,\n        }\n    }\n}\n\nimpl Ord for Operand {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        let partial_result = self.partial_cmp(other);\n\n        match partial_result {\n            Some(ordering) =\u003e ordering,\n            None =\u003e match (self, other) {\n                (Operand::Variable(_), Operand::Temporary(_)) =\u003e std::cmp::Ordering::Greater,\n                (Operand::Variable(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::Temporary(_), Operand::Variable(_)) =\u003e std::cmp::Ordering::Less,\n                (Operand::Temporary(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    std::cmp::Ordering::Greater\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Variable(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n                (Operand::UnsignedDecimalConstant(_), Operand::Temporary(_)) =\u003e {\n                    std::cmp::Ordering::Less\n                }\n\n                (Operand::Variable(_), Operand::Variable(_))\n                | (Operand::Temporary(_), Operand::Temporary(_))\n                | (Operand::UnsignedDecimalConstant(_), Operand::UnsignedDecimalConstant(_)) =\u003e {\n                    panic!(\"Non-covered case in Operand::cmp\")\n                }\n            },\n        }\n    }\n}\n\nimpl Operand {\n    pub fn new_as_variable(identifier: String) -\u003e Self {\n        Operand::Variable(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_temporary(identifier: String) -\u003e Self {\n        Operand::Temporary(OperandName::new_basic(identifier))\n    }\n\n    pub fn new_as_unsigned_decimal_constant(constant: usize) -\u003e Self {\n        Operand::UnsignedDecimalConstant(constant)\n    }\n\n    pub fn type_\u003c'a\u003e(\u0026self, context: \u0026'a linearizer::walkcontext::WalkContext) -\u003e \u0026'a Type {\n        match self {\n            Operand::Variable(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::Temporary(name) =\u003e context\n                .lookup_variable_by_name(\u0026name)\n                .expect(format!(\"Use of undeclared variable {}\", name).as_str())\n                .type_(),\n            Operand::UnsignedDecimalConstant(value) =\u003e {\n                if *value \u003e (u32::MAX as usize) {\n                    \u0026Type::U64\n                } else if *value \u003e (u16::MAX as usize) {\n                    \u0026Type::U32\n                } else if *value \u003e (u8::MAX as usize) {\n                    \u0026Type::U16\n                } else {\n                    \u0026Type::U8\n                }\n            }\n        }\n    }\n\n    pub fn get_name(\u0026self) -\u003e Option\u003c\u0026OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n\n    pub fn get_name_mut(\u0026mut self) -\u003e Option\u003c\u0026mut OperandName\u003e {\n        match self {\n            Operand::Variable(operand_name) =\u003e Some(operand_name),\n            Operand::Temporary(operand_name) =\u003e Some(operand_name),\n            Operand::UnsignedDecimalConstant(_) =\u003e None,\n        }\n    }\n}\n\n/*\n groupings of operands\n*/\n\n#[derive(Debug, Serialize, Clone)]\npub struct DualSourceOperands {\n    pub a: Operand,\n    pub b: Operand,\n}\n\nimpl DualSourceOperands {\n    pub fn new(a: Operand, b: Operand) -\u003e Self {\n        DualSourceOperands { a, b }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct BinaryArithmeticOperands {\n    pub destination: Operand,\n    pub sources: DualSourceOperands,\n}\n\nimpl BinaryArithmeticOperands {\n    pub fn from(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryArithmeticOperands {\n            destination,\n            sources: DualSourceOperands::new(source_a, source_b),\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Clone)]\npub struct SourceDestOperands {\n    pub destination: Operand,\n    pub source: Operand,\n}\n\n#[derive(Debug, Serialize, Clone)]\npub enum JumpCondition {\n    Unconditional,\n    Eq(DualSourceOperands),\n    NE(DualSourceOperands),\n    GT(DualSourceOperands),\n    LT(DualSourceOperands),\n    GE(DualSourceOperands),\n    LE(DualSourceOperands),\n}\n\nimpl Display for JumpCondition {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Unconditional =\u003e {\n                write!(f, \"jmp\")\n            }\n            Self::Eq(operands) =\u003e {\n                write!(f, \"jeq({}, {})\", operands.a, operands.b)\n            }\n            Self::NE(operands) =\u003e {\n                write!(f, \"jne({}, {})\", operands.a, operands.b)\n            }\n            Self::LT(operands) =\u003e {\n                write!(f, \"jl({}, {})\", operands.a, operands.b)\n            }\n            Self::GT(operands) =\u003e {\n                write!(f, \"jg({}, {})\", operands.a, operands.b)\n            }\n            Self::LE(operands) =\u003e {\n                write!(f, \"jle({}, {})\", operands.a, operands.b)\n            }\n            Self::GE(operands) =\u003e {\n                write!(f, \"jge({}, {})\", operands.a, operands.b)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cmp::Ordering;\n\n    use crate::midend::ir::*;\n\n    #[test]\n    fn operand_name_ord() {\n        // non-ssa operand names\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_basic(\"b\".into())),\n            Ordering::Less\n        );\n\n        // ssa operand names\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 4)),\n            Ordering::Equal\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"a\".into(), 5)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 4).cmp(\u0026OperandName::new_ssa(\"b\".into(), 4)),\n            Ordering::Less\n        );\n\n        // mixed ssa and non-ssa\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).cmp(\u0026OperandName::new_ssa(\"a\".into(), 1)),\n            Ordering::Less\n        );\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 1).cmp(\u0026OperandName::new_basic(\"a\".into())),\n            Ordering::Greater\n        );\n    }\n\n    #[test]\n    fn operand_name_into_non_ssa() {\n        assert_eq!(\n            OperandName::new_basic(\"a\".into()).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n\n        assert_eq!(\n            OperandName::new_ssa(\"a\".into(), 123).into_non_ssa(),\n            OperandName::new_basic(\"a\".into())\n        );\n    }\n\n    #[test]\n    fn operand_eq() {\n        // variable against other types\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_variable(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // temporary against other types\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_temporary(\"asdf\".into()),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n\n        // unsigned decimal constant against other types\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_variable(\"asdf\".into())\n        );\n        assert_ne!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_temporary(\"asdf\".into())\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12),\n            Operand::new_as_unsigned_decimal_constant(12)\n        );\n    }\n\n    #[test]\n    fn operand_get_name() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name(),\n            Some(\u0026OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name(),\n            None\n        );\n    }\n\n    #[test]\n    fn operand_get_name_mut() {\n        assert_eq!(\n            Operand::new_as_variable(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_temporary(\"asdf\".into()).get_name_mut(),\n            Some(\u0026mut OperandName::new_basic(\"asdf\".into()))\n        );\n        assert_eq!(\n            Operand::new_as_unsigned_decimal_constant(12).get_name_mut(),\n            None\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":40}},{"line":15,"address":[],"length":0,"stats":{"Line":80}},{"line":22,"address":[],"length":0,"stats":{"Line":9}},{"line":24,"address":[],"length":0,"stats":{"Line":9}},{"line":25,"address":[],"length":0,"stats":{"Line":9}},{"line":26,"address":[],"length":0,"stats":{"Line":9}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":9}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":112}},{"line":65,"address":[],"length":0,"stats":{"Line":9}},{"line":68,"address":[],"length":0,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":9}},{"line":106,"address":[],"length":0,"stats":{"Line":9}},{"line":113,"address":[],"length":0,"stats":{"Line":9}},{"line":114,"address":[],"length":0,"stats":{"Line":9}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":9}},{"line":132,"address":[],"length":0,"stats":{"Line":9}},{"line":134,"address":[],"length":0,"stats":{"Line":9}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":54}},{"line":164,"address":[],"length":0,"stats":{"Line":54}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":11}},{"line":172,"address":[],"length":0,"stats":{"Line":11}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":20}},{"line":200,"address":[],"length":0,"stats":{"Line":20}},{"line":201,"address":[],"length":0,"stats":{"Line":18}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":20}},{"line":208,"address":[],"length":0,"stats":{"Line":20}},{"line":209,"address":[],"length":0,"stats":{"Line":18}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":242,"address":[],"length":0,"stats":{"Line":3}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}}],"covered":65,"coverable":107},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","operations.rs"],"content":"use serde::Serialize;\nuse std::{collections::HashMap, fmt::Display};\n\nuse super::operands::*;\n\n/// ## Binary Operations\n#[derive(Debug, Serialize, Clone)]\npub enum BinaryOperations {\n    Add(BinaryArithmeticOperands),\n    Subtract(BinaryArithmeticOperands),\n    Multiply(BinaryArithmeticOperands),\n    Divide(BinaryArithmeticOperands),\n    LThan(BinaryArithmeticOperands),\n    GThan(BinaryArithmeticOperands),\n    LThanE(BinaryArithmeticOperands),\n    GThanE(BinaryArithmeticOperands),\n    Equals(BinaryArithmeticOperands),\n    NotEquals(BinaryArithmeticOperands),\n}\n\nimpl Display for BinaryOperations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Add(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} + {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Subtract(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} - {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Multiply(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} * {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Divide(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} / {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThan(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::LThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003c= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::GThanE(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} \u003e= {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::Equals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} == {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n            Self::NotEquals(operands) =\u003e {\n                write!(\n                    f,\n                    \"{} = {} != {}\",\n                    operands.destination, operands.sources.a, operands.sources.b\n                )\n            }\n        }\n    }\n}\n\nimpl BinaryOperations {\n    pub fn new_add(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Add(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_subtract(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Subtract(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_multiply(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Multiply(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_divide(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Divide(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThan(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_lthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::LThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_gthan_e(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::GThanE(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::Equals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn new_not_equals(destination: Operand, source_a: Operand, source_b: Operand) -\u003e Self {\n        BinaryOperations::NotEquals(BinaryArithmeticOperands::from(\n            destination,\n            source_a,\n            source_b,\n        ))\n    }\n\n    pub fn raw_operands(\u0026self) -\u003e \u0026BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n\n    pub fn raw_operands_mut(\u0026mut self) -\u003e \u0026mut BinaryArithmeticOperands {\n        match self {\n            Self::Add(ops)\n            | Self::Subtract(ops)\n            | Self::Multiply(ops)\n            | Self::Divide(ops)\n            | Self::LThan(ops)\n            | Self::GThan(ops)\n            | Self::LThanE(ops)\n            | Self::GThanE(ops)\n            | Self::Equals(ops)\n            | Self::NotEquals(ops) =\u003e ops,\n        }\n    }\n}\n\n/// ## Jump\n#[derive(Debug, Serialize, Clone)]\npub struct JumpOperation {\n    pub destination_block: usize,\n    pub block_args: HashMap\u003cOperandName, OperandName\u003e,\n    pub condition: JumpCondition,\n}\n\nimpl Display for JumpOperation {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut block_args_string = String::new();\n        for (arg, operand) in \u0026self.block_args {\n            block_args_string += \u0026format!(\"{}:{} \", arg, operand);\n        }\n        write!(\n            f,\n            \"{} Block{}({})\",\n            self.condition, self.destination_block, block_args_string\n        )\n    }\n}\n\nimpl JumpOperation {\n    pub fn new(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self {\n            destination_block,\n            block_args: HashMap::new(),\n            condition,\n        }\n    }\n}\n\n/// ## Enum of all operations\n#[derive(Debug, Serialize, Clone)]\npub enum Operations {\n    Assignment(SourceDestOperands),\n    BinaryOperation(BinaryOperations),\n    Jump(JumpOperation),\n}\n\nimpl Display for Operations {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Assignment(assignment) =\u003e {\n                write!(f, \"{} = {}\", assignment.destination, assignment.source)\n            }\n            Self::BinaryOperation(binary_operation) =\u003e {\n                write!(f, \"{}\", binary_operation)\n            }\n            Self::Jump(jump) =\u003e {\n                write!(f, \"{}\", jump)\n            }\n        }\n    }\n}\n\nimpl Operations {\n    pub fn new_assignment(destination: Operand, source: Operand) -\u003e Self {\n        Self::Assignment(SourceDestOperands {\n            destination,\n            source,\n        })\n    }\n\n    pub fn new_jump(destination_block: usize, condition: JumpCondition) -\u003e Self {\n        Self::Jump(JumpOperation::new(destination_block, condition))\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":25}},{"line":236,"address":[],"length":0,"stats":{"Line":25}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[],"length":0,"stats":{"Line":3}},{"line":274,"address":[],"length":0,"stats":{"Line":13}},{"line":275,"address":[],"length":0,"stats":{"Line":13}}],"covered":26,"coverable":139},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ir","tests.rs"],"content":"use crate::{frontend::sourceloc::SourceLoc, midend::ir::*};\n\nuse super::{IrLine, Operand};\n\n#[test]\nfn ir_line_new_assignment() {\n    let assignment = IrLine::new_assignment(\n        SourceLoc::new(123, 456),\n        Operand::new_as_variable(\"a\".into()),\n        Operand::new_as_unsigned_decimal_constant(99),\n    );\n\n    assert_eq!(assignment.loc, SourceLoc::new(123, 456));\n    assert!(matches!(assignment.operation, Operations::Assignment(_)));\n}\n\n#[test]\nfn ir_line_new_binary_op() {\n    let binary_operation = IrLine::new_binary_op(\n        SourceLoc::new(123, 456),\n        BinaryOperations::new_add(\n            Operand::new_as_variable(\"result\".into()),\n            Operand::new_as_variable(\"a\".into()),\n            Operand::new_as_variable(\"b\".into()),\n        ),\n    );\n\n    assert_eq!(binary_operation.loc, SourceLoc::new(123, 456));\n    assert!(matches!(\n        binary_operation.operation,\n        Operations::BinaryOperation(_)\n    ));\n}\n\n#[test]\nfn ir_line_new_jump() {\n    let jump = IrLine::new_jump(SourceLoc::new(123, 456), 8, JumpCondition::Unconditional);\n\n    assert_eq!(jump.loc, SourceLoc::new(123, 456));\n    assert!(matches!(jump.operation, Operations::Jump(_)));\n}\n\nfn operand_from_string(name: \u0026str) -\u003e Operand {\n    Operand::new_as_variable(name.into())\n}\n\nfn line_from_op(operation: Operations) -\u003e IrLine {\n    IrLine::new(SourceLoc::new(0, 0), operation)\n}\n\nfn operand_name_from_string(name: \u0026str) -\u003e OperandName {\n    OperandName::new_basic(name.into())\n}\n\n#[test]\nfn read_operand_names() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n\n#[test]\nfn read_operand_names_mut() {\n    // assignment op\n    let mut op = line_from_op(Operations::Assignment(SourceDestOperands {\n        destination: operand_from_string(\"assignment_destination\"),\n        source: operand_from_string(\"assignment_source\"),\n    }));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"assignment_source\")]\n    );\n\n    // binary operation\n    op = line_from_op(Operations::BinaryOperation(BinaryOperations::new_subtract(\n        operand_from_string(\"binary_op_destination\"),\n        operand_from_string(\"binary_op_source_a\"),\n        operand_from_string(\"binary_op_source_b\"),\n    )));\n    assert_eq!(\n        op.write_operand_names_mut(),\n        vec![\u0026operand_name_from_string(\"binary_op_destination\")]\n    );\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"binary_op_source_a\"),\n            \u0026operand_name_from_string(\"binary_op_source_b\")\n        ]\n    );\n\n    // jeq\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::Eq(DualSourceOperands::new(\n            operand_from_string(\"eq_a\"),\n            operand_from_string(\"eq_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"eq_a\"),\n            \u0026operand_name_from_string(\"eq_b\")\n        ]\n    );\n\n    // jne\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::NE(DualSourceOperands::new(\n            operand_from_string(\"ne_a\"),\n            operand_from_string(\"ne_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ne_a\"),\n            \u0026operand_name_from_string(\"ne_b\")\n        ]\n    );\n\n    // jg\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GT(DualSourceOperands::new(\n            operand_from_string(\"gt_a\"),\n            operand_from_string(\"gt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"gt_a\"),\n            \u0026operand_name_from_string(\"gt_b\")\n        ]\n    );\n\n    // jl\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LT(DualSourceOperands::new(\n            operand_from_string(\"lt_a\"),\n            operand_from_string(\"lt_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"lt_a\"),\n            \u0026operand_name_from_string(\"lt_b\")\n        ]\n    );\n\n    // ge\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::GE(DualSourceOperands::new(\n            operand_from_string(\"ge_a\"),\n            operand_from_string(\"ge_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"ge_a\"),\n            \u0026operand_name_from_string(\"ge_b\")\n        ]\n    );\n\n    // le\n    op = line_from_op(Operations::Jump(JumpOperation::new(\n        1,\n        JumpCondition::LE(DualSourceOperands::new(\n            operand_from_string(\"le_a\"),\n            operand_from_string(\"le_b\"),\n        )),\n    )));\n    assert_eq!(op.write_operand_names_mut(), Vec::\u003c\u0026OperandName\u003e::new());\n    assert_eq!(\n        op.read_operand_names_mut(),\n        vec![\n            \u0026operand_name_from_string(\"le_a\"),\n            \u0026operand_name_from_string(\"le_b\")\n        ]\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","mod.rs"],"content":"use treewalk::TableWalk;\n\nuse crate::frontend::ast::TranslationUnitTree;\n\nuse super::symtab::SymbolTable;\n\nmod treewalk;\npub mod walkcontext;\n\npub fn linearize(symtab: \u0026mut SymbolTable, program: Vec\u003cTranslationUnitTree\u003e) {\n    for translation_unit in program {\n        translation_unit.walk(symtab);\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","treewalk.rs"],"content":"use crate::{\n    frontend::{ast::*, sourceloc::SourceLoc},\n    midend::{\n        ir::{self, IrLine},\n        symtab::{self, SymbolTable},\n        types::Type,\n    },\n};\n\nuse super::walkcontext::WalkContext;\n\npub trait TableWalk {\n    fn walk(self, symbol_table: \u0026mut SymbolTable);\n}\n\npub trait ReturnWalk\u003cT\u003e {\n    fn walk(self) -\u003e T;\n}\n\npub trait ContextWalk {\n    fn walk(self, context: \u0026mut WalkContext);\n}\n\npub trait OperandWalk {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand;\n}\n\nimpl TableWalk for TranslationUnitTree {\n    fn walk(self, symbol_table: \u0026mut SymbolTable) {\n        match self.contents {\n            TranslationUnit::FunctionDeclaration(tree) =\u003e {\n                let declared_function = tree.walk();\n                symbol_table.insert_function_prototype(declared_function);\n            }\n            TranslationUnit::FunctionDefinition(tree) =\u003e {\n                let mut declared_prototype = tree.prototype.walk();\n                let mut context = WalkContext::new();\n                context.push_scope(declared_prototype.create_argument_scope());\n\n                tree.body.walk(\u0026mut context);\n                let argument_scope = context.pop_last_scope();\n\n                symbol_table.insert_function(symtab::Function::new(\n                    declared_prototype,\n                    argument_scope,\n                    context.take_control_flow(),\n                ));\n            }\n        }\n    }\n}\n\nimpl ReturnWalk\u003cType\u003e for TypenameTree {\n    fn walk(self) -\u003e Type {\n        self.type_\n    }\n}\n\nimpl ReturnWalk\u003csymtab::Variable\u003e for VariableDeclarationTree {\n    fn walk(self) -\u003e symtab::Variable {\n        symtab::Variable::new(self.name.clone(), self.typename.walk())\n    }\n}\n\nimpl ReturnWalk\u003csymtab::FunctionPrototype\u003e for FunctionDeclarationTree {\n    fn walk(self) -\u003e symtab::FunctionPrototype {\n        symtab::FunctionPrototype::new(\n            self.name,\n            self.arguments.into_iter().map(|x| x.walk()).collect(),\n            match self.return_type {\n                Some(typename) =\u003e Some(typename.walk()),\n                None =\u003e None,\n            },\n        )\n    }\n}\n\nimpl OperandWalk for ArithmeticOperationTree {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        let (temp_dest, op) = match self {\n            ArithmeticOperationTree::Add(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_add(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Subtract(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_subtract(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Multiply(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_multiply(dest, lhs, rhs),\n                )\n            }\n            ArithmeticOperationTree::Divide(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_divide(dest, lhs, rhs),\n                )\n            }\n        };\n\n        let operation = IrLine::new_binary_op(loc, op);\n        context.append_statement_to_current_block(operation);\n        temp_dest\n    }\n}\n\nimpl OperandWalk for ComparisonOperationTree {\n    fn walk(self, loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        let (temp_dest, op) = match self {\n            ComparisonOperationTree::LThan(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::GThan(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::LThanE(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_lthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::GThanE(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_gthan_e(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::Equals(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_equals(dest, lhs, rhs),\n                )\n            }\n            ComparisonOperationTree::NotEquals(operands) =\u003e {\n                let lhs = operands.e1.walk(loc, context);\n                let rhs = operands.e2.walk(loc, context);\n                let dest = context.next_temp(lhs.type_(context).clone());\n                (\n                    dest.clone(),\n                    ir::operations::BinaryOperations::new_not_equals(dest, lhs, rhs),\n                )\n            }\n        };\n        let operation = IrLine::new_binary_op(loc, op);\n        context.append_statement_to_current_block(operation);\n        temp_dest\n    }\n}\n\nimpl OperandWalk for ExpressionTree {\n    fn walk(self, _loc: SourceLoc, context: \u0026mut WalkContext) -\u003e ir::Operand {\n        match self.expression {\n            Expression::Identifier(ident) =\u003e ir::Operand::new_as_variable(ident),\n            Expression::UnsignedDecimalConstant(constant) =\u003e {\n                ir::Operand::new_as_unsigned_decimal_constant(constant)\n            }\n            Expression::Arithmetic(arithmetic_operation) =\u003e {\n                arithmetic_operation.walk(self.loc, context)\n            }\n            Expression::Comparison(comparison_operation) =\u003e {\n                comparison_operation.walk(self.loc, context)\n            }\n        }\n    }\n}\n\nimpl ContextWalk for AssignmentTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        let assignment_ir = IrLine::new_assignment(\n            self.loc,\n            ir::Operand::new_as_variable(self.identifier),\n            self.value.walk(self.loc, context),\n        );\n        context.append_statement_to_current_block(assignment_ir);\n    }\n}\n\nimpl ContextWalk for IfStatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        // FUTURE: optimize condition walk to use different jumps\n        let condition_loc = self.condition.loc.clone();\n        let condition_result = self.condition.walk(condition_loc, context);\n        let if_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n\n        let (_, maybe_else_label) =\n            context.create_conditional_branch_from_current(condition_loc, if_condition);\n        self.true_block.walk(context);\n        context.converge_current_block();\n\n        match (maybe_else_label, self.false_block) {\n            (Some(else_label), Some(else_block)) =\u003e {\n                context.set_current_block(else_label);\n                else_block.walk(context);\n                context.converge_current_block();\n            }\n            (None, None) =\u003e {}\n            (_, _) =\u003e {\n                panic!(\n                    \"Mismatched else label and else block - expect to have either both or neither\"\n                );\n            }\n        };\n    }\n}\n\nimpl ContextWalk for WhileLoopTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        let loop_done = context.create_loop(self.loc, self.condition);\n\n        self.body.walk(context);\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n    }\n}\n\nimpl ContextWalk for StatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        match self.statement {\n            Statement::VariableDeclaration(tree) =\u003e context.scope().insert_variable(tree.walk()),\n            Statement::Assignment(tree) =\u003e tree.walk(context),\n            Statement::IfStatement(tree) =\u003e tree.walk(context),\n            Statement::WhileLoop(tree) =\u003e tree.walk(context),\n        }\n    }\n}\n\nimpl ContextWalk for CompoundStatementTree {\n    fn walk(self, context: \u0026mut WalkContext) {\n        context.push_scope(symtab::Scope::new());\n        for statement in self.statements {\n            statement.walk(context);\n        }\n        context.pop_scope_to_subscope_of_next();\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":143},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","linearizer","walkcontext.rs"],"content":"use std::collections::{HashMap, HashSet};\n\nuse crate::{\n    frontend::{ast, sourceloc::SourceLoc},\n    midend::{ir, symtab, types::Type},\n};\n\nuse super::treewalk::*;\n\npub struct WalkContext {\n    control_flow: ir::ControlFlow,\n    branch_points: HashMap\u003cusize, HashSet\u003cusize\u003e\u003e, // map from branch origin to set of target blocks\n    convergence_points: HashMap\u003cusize, usize\u003e, // map of label -\u003e label that block should jump to when done\n    scopes: Vec\u003csymtab::Scope\u003e,\n    // index of number of temporary variables used in this control flow (across all blocks)\n    temp_num: usize,\n    current_block: usize,\n}\n\nimpl WalkContext {\n    pub fn new() -\u003e WalkContext {\n        let starter_flow = ir::ControlFlow::new();\n\n        let mut convergence_points = HashMap::\u003cusize, usize\u003e::new();\n        convergence_points.insert(0, 1);\n\n        WalkContext {\n            control_flow: starter_flow,\n            branch_points: HashMap::\u003cusize, HashSet\u003cusize\u003e\u003e::new(),\n            convergence_points,\n            scopes: Vec::new(),\n            temp_num: 0,\n            current_block: 0,\n        }\n    }\n\n    pub fn take_control_flow(mut self) -\u003e ir::ControlFlow {\n        for (from, to) in self.convergence_points.clone() {\n            assert_eq!(self.converge_block(from), to); // TODO: need assert?\n        }\n        self.control_flow\n    }\n\n    fn replace_branch_and_convergence_points(\u0026mut self, old_block: usize, new_block: usize) {\n        // replace all instances of old_block with new_block in both branch and convergence point tracking\n        // self.branch_points = self\n        //     .branch_points\n        //     .iter()\n        //     .map(|(source, dest_set)| {\n        //         (\n        //             if *source == old_block {\n        //                 new_block\n        //             } else {\n        //                 *source\n        //             },\n        //             dest_set\n        //                 .into_iter()\n        //                 .map(|target| {\n        //                     if *target == old_block {\n        //                         new_block\n        //                     } else {\n        //                         *target\n        //                     }\n        //                 })\n        //                 .collect(),\n        //         )\n        //     })\n        //     .collect();\n\n        self.convergence_points = self\n            .convergence_points\n            .iter()\n            .map(|(from, to)| {\n                (\n                    if *from == old_block { new_block } else { *from },\n                    if *to == old_block { new_block } else { *to },\n                )\n            })\n            .collect();\n    }\n\n    pub fn append_statement_to_current_block(\u0026mut self, statement: ir::IrLine) {\n        match \u0026statement.operation {\n            ir::Operations::Jump(_) =\u003e {\n                panic!(\"WalkContext::append_statement_to_current_block does NOT support jumps!\")\n            }\n            _ =\u003e {}\n        }\n        self.append_to_current_block(statement);\n    }\n\n    ///appends the given statement to the current basic block\n    ///if the statement is any sort of branch, the current block will be updated to be the target of the branch\n    ///if the branch is conditional, the function returns Some(false_label) where false_label is the target of the\n    ///block control flows to when the condition is not met\n    ///for unconditional branches and other statements, returns None\n    fn append_to_current_block(\u0026mut self, statement: ir::IrLine) -\u003e Option\u003cusize\u003e {\n        match self\n            .control_flow\n            .append_statement_to_block(statement, self.current_block)\n        {\n            (Some(new_current), false_label) =\u003e {\n                self.replace_branch_and_convergence_points(self.current_block, new_current);\n                self.set_current_block(new_current);\n                false_label\n            }\n            (None, _) =\u003e None,\n        }\n    }\n\n    /// creates a branch from the current block based on a condition\n    /// returns the target of the branch\n    fn create_branch_from_current(\u0026mut self) -\u003e usize {\n        let branch_target = self.control_flow.next_block();\n\n        match self.branch_points.get(\u0026self.current_block) {\n            Some(_) =\u003e panic!(\n                \"create_branch_from_current called with existing branch (from block {})\",\n                self.current_block\n            ),\n            None =\u003e {\n                self.branch_points\n                    .insert(self.current_block, HashSet::new());\n            }\n        };\n\n        self.branch_points\n            .get_mut(\u0026self.current_block)\n            .unwrap()\n            .insert(branch_target);\n        branch_target\n    }\n\n    fn add_branch(\u0026mut self, from: usize, to: usize) {\n        self.branch_points\n            .get_mut(\u0026from)\n            .expect(\"add_branch expects existing branch\")\n            .insert(to);\n    }\n\n    fn add_convergence_point_for_branch(\u0026mut self, from: usize, to: usize) {\n        match self.convergence_points.insert(from, to) {\n            Some(existing_convergence) =\u003e {\n                if existing_convergence != to {\n                    self.add_convergence_point_for_branch(to, existing_convergence);\n                }\n            }\n            None =\u003e {}\n        }\n    }\n\n    fn create_convergence_points_for_branch(\u0026mut self, branch_from: usize) -\u003e usize {\n        let convergence_point = match self.convergence_points.get(\u0026branch_from) {\n            Some(existing_convergence) =\u003e *existing_convergence,\n            None =\u003e self.control_flow.next_block(),\n        };\n\n        for branch_target in self\n            .branch_points\n            .get(\u0026branch_from)\n            .expect(\"Creation of convergence points requires existence of branch(es)\")\n            .clone()\n        {\n            self.add_convergence_point_for_branch(branch_target, convergence_point);\n        }\n        convergence_point\n    }\n\n    ///append an unconditional jump from the end of block_label to its convergence point\n    ///return the block to which control has converged\n    fn converge_block(\u0026mut self, block_label: usize) -\u003e usize {\n        let converge_to = self\n            .convergence_points\n            .remove(\u0026block_label)\n            .expect(\u0026format!(\"Block {} has no convergence point\", block_label));\n\n        let convergence_jump = ir::IrLine::new_jump(\n            SourceLoc::none(),\n            converge_to,\n            ir::JumpCondition::Unconditional,\n        );\n        // ignore return value - appending an unconditional jump\n        self.control_flow\n            .append_statement_to_block(convergence_jump, block_label);\n        converge_to\n    }\n\n    pub fn converge_current_block(\u0026mut self) {\n        let converged_to = self.converge_block(self.current_block);\n        self.set_current_block(converged_to);\n    }\n\n    pub fn set_current_block(\u0026mut self, label: usize) {\n        self.current_block = label;\n    }\n\n    pub fn create_conditional_branch_from_current(\n        \u0026mut self,\n        loc: SourceLoc,\n        condition: ir::JumpCondition,\n    ) -\u003e (usize, Option\u003cusize\u003e) {\n        let branch_origin = self.current_block;\n        let true_label = self.create_branch_from_current();\n\n        let true_condition_jump = ir::IrLine::new_jump(loc, true_label, condition);\n        let maybe_false_label = self.append_to_current_block(true_condition_jump);\n        match maybe_false_label {\n            Some(false_label) =\u003e self.add_branch(branch_origin, false_label),\n            None =\u003e {}\n        }\n\n        self.create_convergence_points_for_branch(branch_origin);\n\n        (true_label, maybe_false_label)\n    }\n\n    ///returns the label which control jumps to after the loop\n    pub fn create_loop(\u0026mut self, loc: SourceLoc, condition: ast::ExpressionTree) -\u003e usize {\n        // first, jump to a fresh block which will be the top of the loop\n        let loop_top = self.control_flow.next_block();\n        let loop_entry = ir::IrLine::new_jump(loc, loop_top, ir::JumpCondition::Unconditional);\n        // ignore return value - appending an unconditional jump\n        self.append_to_current_block(loop_entry);\n\n        // FUTURE: optimize condition walk to use different jumps\n        // check the condition of the loop, giving us the loop body and loop done labels\n        let condition_loc = condition.loc.clone();\n        let condition_result = condition.walk(condition_loc, self);\n        let loop_condition = ir::JumpCondition::NE(ir::operands::DualSourceOperands::new(\n            condition_result,\n            ir::Operand::new_as_unsigned_decimal_constant(0),\n        ));\n        let (_, loop_done_label) =\n            self.create_conditional_branch_from_current(condition_loc, loop_condition);\n        let loop_done_label = loop_done_label.unwrap();\n\n        self.convergence_points.insert(self.current_block, loop_top);\n        self.converge_block(loop_done_label);\n\n        loop_done_label\n    }\n\n    pub fn next_temp(\u0026mut self, type_: Type) -\u003e ir::Operand {\n        let temp_name = String::from(\".T\") + \u0026self.temp_num.to_string();\n        self.temp_num += 1;\n        self.scope()\n            .insert_variable(symtab::Variable::new(temp_name.clone(), type_));\n        ir::Operand::new_as_temporary(temp_name)\n    }\n\n    pub fn push_scope(\u0026mut self, scope: symtab::Scope) {\n        self.scopes.push(scope)\n    }\n\n    pub fn pop_scope_to_subscope_of_next(\u0026mut self) {\n        let popped = self\n            .scopes\n            .pop()\n            .expect(\"WalkContext::pop_scope_to_subscope_of_next expects valid scope\");\n        self.scope().insert_subscope(popped);\n    }\n\n    pub fn pop_last_scope(\u0026mut self) -\u003e symtab::Scope {\n        if self.scopes.len() \u003e 1 {\n            panic!(\n                \"WalkContext::pop_last_scope() called with {} parent scopes\",\n                self.scopes.len()\n            );\n        }\n\n        self.scopes\n            .pop()\n            .expect(\"WalkContext::pop_last_scope() called with no scopese\")\n    }\n\n    pub fn scope(\u0026mut self) -\u003e \u0026mut symtab::Scope {\n        self.scopes\n            .last_mut()\n            .expect(\"WalkContext::scope() expects valid scope\")\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026ir::OperandName) -\u003e Option\u003c\u0026symtab::Variable\u003e {\n        for scope in (\u0026self.scopes).into_iter().rev().by_ref() {\n            match scope.lookup_variable_by_name(\u0026name.base_name) {\n                Some(variable) =\u003e return Some(variable),\n                None =\u003e {}\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        frontend::{ast, sourceloc::SourceLoc},\n        midend::{ir, linearizer::walkcontext::WalkContext, symtab},\n    };\n\n    fn assert_no_remaining_convergences(context: WalkContext) {\n        // allow convergence to block 1 as that should be the final block in the control flow\n        for (from, to) in context.convergence_points {\n            assert_eq!(to, 1);\n        }\n    }\n\n    fn assert_branch(context: \u0026WalkContext, from: usize, to: usize) {\n        let branches = context.branch_points.get(\u0026from);\n        assert!(branches.is_some());\n        let branches = branches.unwrap();\n        assert!(branches.contains(\u0026to));\n    }\n\n    fn assert_convergence(context: \u0026WalkContext, from: usize, to: usize) {\n        let convergence = context.convergence_points.get(\u0026from);\n        assert_eq!(convergence, Some(\u0026to));\n    }\n\n    #[test]\n    fn walk_context_initial_state() {\n        let context = WalkContext::new();\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn append_statement() {\n        let mut context = WalkContext::new();\n        let assignment = ir::IrLine::new_assignment(\n            SourceLoc::none(),\n            ir::Operand::new_as_variable(\"dest\".into()),\n            ir::Operand::new_as_variable(\"source\".into()),\n        );\n        context.append_statement_to_current_block(assignment);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_branch() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n    }\n\n    #[test]\n    fn add_branch() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n        assert_eq!(branch_to, 2);\n        assert_eq!(second_branch_to, 3);\n    }\n\n    #[test]\n    fn simple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n        assert_eq!(branch_to, 2);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n    }\n\n    #[test]\n    fn complex_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n\n        // create the convergence point and assert that both branch targets converge to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn simple_multiple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 2 targets, nested in a branch with one target\n    #[test]\n    fn complex_multiple_branch_convergence_points() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_from = context.current_block;\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, nested_branch_from, nested_branch_to);\n\n        // and add to that second branch a second target\n        let second_nested_branch_to = context.control_flow.next_block();\n        context.add_branch(nested_branch_from, second_nested_branch_to);\n        assert_branch(\u0026context, nested_branch_from, second_nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(nested_branch_from);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n        assert_convergence(\u0026context, nested_branch_to, nested_converge_to);\n    }\n\n    ///test a branch with 1 target, nested within a branch with 2 targets\n    #[test]\n    fn complex_multiple_branch_convergence_points_2() {\n        let mut context = WalkContext::new();\n\n        // branch from the current block to somewhere\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_from, branch_to);\n\n        // also branch to a second place\n        let second_branch_to = context.control_flow.next_block();\n        context.add_branch(branch_from, second_branch_to);\n        assert_branch(\u0026context, branch_from, second_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n\n        // now, create a second nested branch within the first branch\n        context.set_current_block(branch_to);\n        let nested_branch_to = context.create_branch_from_current();\n        assert_branch(\u0026context, branch_to, nested_branch_to);\n\n        // create our convergence point, and assert that we converge back to it\n        let nested_converge_to = context.create_convergence_points_for_branch(branch_to);\n        assert_convergence(\u0026context, branch_to, nested_converge_to);\n\n        // and re-assert our original convergence\n        assert_convergence(\u0026context, branch_to, converge_to);\n        assert_convergence(\u0026context, second_branch_to, converge_to);\n    }\n\n    #[test]\n    fn converge_block() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        assert_eq!(context.converge_block(branch_to), converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn converge_current_block() {\n        let mut context = WalkContext::new();\n\n        let branch_from = context.current_block;\n        let branch_to = context.create_branch_from_current();\n        let converge_to = context.create_convergence_points_for_branch(branch_from);\n\n        context.set_current_block(branch_to);\n        context.converge_current_block();\n\n        assert_eq!(context.current_block, converge_to);\n\n        assert_no_remaining_convergences(context);\n    }\n\n    #[test]\n    fn create_loop() {\n        let mut context = WalkContext::new();\n        context.push_scope(symtab::Scope::new());\n\n        let before_loop = context.current_block;\n\n        let loop_done = context.create_loop(\n            SourceLoc::none(),\n            ast::ExpressionTree {\n                loc: SourceLoc::none(),\n                expression: { ast::Expression::UnsignedDecimalConstant(123) },\n            },\n        );\n\n        assert_ne!(before_loop, context.current_block);\n        assert_ne!(loop_done, context.current_block);\n\n        context.converge_current_block();\n        context.set_current_block(loop_done);\n\n        assert_no_remaining_convergences(context);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":24,"address":[],"length":0,"stats":{"Line":12}},{"line":25,"address":[],"length":0,"stats":{"Line":12}},{"line":29,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":13}},{"line":114,"address":[],"length":0,"stats":{"Line":13}},{"line":116,"address":[],"length":0,"stats":{"Line":13}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":13}},{"line":122,"address":[],"length":0,"stats":{"Line":13}},{"line":123,"address":[],"length":0,"stats":{"Line":13}},{"line":127,"address":[],"length":0,"stats":{"Line":13}},{"line":128,"address":[],"length":0,"stats":{"Line":13}},{"line":130,"address":[],"length":0,"stats":{"Line":13}},{"line":131,"address":[],"length":0,"stats":{"Line":13}},{"line":134,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":138,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":16}},{"line":142,"address":[],"length":0,"stats":{"Line":16}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":15}},{"line":152,"address":[],"length":0,"stats":{"Line":11}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":154,"address":[],"length":0,"stats":{"Line":10}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":26}},{"line":159,"address":[],"length":0,"stats":{"Line":11}},{"line":160,"address":[],"length":0,"stats":{"Line":11}},{"line":161,"address":[],"length":0,"stats":{"Line":11}},{"line":162,"address":[],"length":0,"stats":{"Line":11}},{"line":164,"address":[],"length":0,"stats":{"Line":15}},{"line":166,"address":[],"length":0,"stats":{"Line":11}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":9}},{"line":194,"address":[],"length":0,"stats":{"Line":9}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}}],"covered":100,"coverable":132},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","mod.rs"],"content":"use symtab::SymbolTable;\n\nuse crate::frontend;\n\nmod idfa;\npub mod ir;\npub mod linearizer;\nmod optimization;\nmod ssa_gen;\npub mod symtab;\npub mod types;\n\npub fn symbol_table_from_program(\n    program: Vec\u003cfrontend::ast::TranslationUnitTree\u003e,\n) -\u003e symtab::SymbolTable {\n    let mut symtab = SymbolTable::new();\n    linearizer::linearize(\u0026mut symtab, program);\n\n    ssa_gen::convert_functions_to_ssa(\u0026mut symtab.functions);\n\n    optimization::optimize_functions(\u0026mut symtab.functions);\n\n    symtab\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","optimization","mod.rs"],"content":"use std::collections::HashMap;\n\nuse super::symtab::{Function, FunctionOrPrototype};\n\nmod unused_blocks;\n\nfn do_optimizations_on_function(function: \u0026mut Function) {\n    // unused_blocks::remove_unused_blocks(function);\n}\n\npub fn optimize_functions(functions: \u0026mut HashMap\u003cString, FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            FunctionOrPrototype::Prototype(_) =\u003e {}\n            FunctionOrPrototype::Function(function) =\u003e do_optimizations_on_function(function),\n        };\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","optimization","unused_blocks.rs"],"content":"// use std::collections::{BTreeSet, HashMap, HashSet};\n\n// use crate::midend::{\n//     ir::{self, ControlFlow},\n//     symtab::Function,\n// };\n\n// pub fn remove_unused_blocks(function: \u0026mut Function) {\n//     let mut block_references = HashMap::\u003cusize, usize\u003e::new();\n\n//     for label_num in 0..function.control_flow.blocks.len() {\n//         block_references.entry(label_num).or_insert(0);\n//         for target in \u0026function.control_flow.successors[label_num] {\n//             *block_references.entry(*target).or_insert(0) += 1;\n//         }\n//     }\n\n//     let mut block_labels_to_remove = BTreeSet::\u003cusize\u003e::new();\n\n//     for (block, rc) in block_references {\n//         println!(\"{}:{}\", block, rc);\n//         if rc == 0 {\n//             block_labels_to_remove.insert(block);\n//         }\n//     }\n\n//     let mut block_labels_to_rename = HashMap::\u003cusize, usize\u003e::new();\n//     for label_num in \u0026block_labels_to_remove {\n//         for affected in *label_num..function.control_flow.blocks.len() {\n//             if !block_labels_to_remove.contains(\u0026affected) {\n//                 *block_labels_to_rename.entry(affected).or_insert(affected) -= 1;\n//             }\n//         }\n//     }\n\n//     for (orig, renamed) in \u0026block_labels_to_rename {\n//         println!(\"{}-\u003e{}\", orig, renamed);\n//     }\n\n//     for block in \u0026mut function.control_flow.blocks {\n//         for statement in block.statements_mut() {\n//             match \u0026mut statement.operation {\n//                 ir::Operations::Jump(jump) =\u003e {\n//                     let original_destination = jump.destination_block;\n//                     jump.destination_block = match block_labels_to_rename.get(\u0026original_destination)\n//                     {\n//                         Some(new_label) =\u003e *new_label,\n//                         None =\u003e original_destination,\n//                     };\n//                 }\n//                 _ =\u003e {}\n//             }\n//         }\n//     }\n\n//     for (old_label, new_label) in \u0026block_labels_to_rename {\n//         function.control_flow.blocks[*old_label].label = *new_label;\n//         println!(\"Rename {}-\u003e{}\", old_label, new_label);\n//     }\n\n//     for remove in block_labels_to_remove.iter().rev() {\n//         println!(\"Remove unused block {}\", remove);\n//         function.control_flow.blocks.remove(*remove);\n//         function.control_flow.successors.remove(*remove);\n//         function.control_flow.predecessors.remove(*remove);\n//     }\n\n//     for predecessor_set in \u0026mut function.control_flow.predecessors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for predecessor in predecessor_set.iter() {\n//             let original_predecessor = predecessor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *predecessor,\n//             });\n//         }\n\n//         *predecessor_set = new_set;\n//     }\n\n//     for successor_set in \u0026mut function.control_flow.successors {\n//         let mut new_set = HashSet::\u003cusize\u003e::new();\n\n//         for successor in successor_set.iter() {\n//             let original_predecessor = successor;\n//             new_set.insert(match block_labels_to_rename.get(\u0026original_predecessor) {\n//                 Some(new_label) =\u003e *new_label,\n//                 None =\u003e *successor,\n//             });\n//         }\n\n//         *successor_set = new_set;\n//     }\n\n//     function.control_flow.to_graphviz();\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa.rs"],"content":"struct SsaBlock {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","add_block_args.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse crate::midend::idfa::block_args::IdfaImplementor;\nuse crate::midend::{\n    idfa::{self},\n    ir, symtab,\n};\n\npub fn add_block_arguments(function: \u0026mut symtab::Function) {\n    let mut block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n\n    loop {\n        let mut args_by_block = HashMap::\u003cusize, BTreeSet\u003cir::OperandName\u003e\u003e::new();\n        for (label, block) in \u0026mut function.control_flow.blocks {\n            block.arguments = block_args.for_label(*label).out_facts.clone();\n            args_by_block.insert(*label, block.arguments.clone());\n        }\n\n        for block in function.control_flow.blocks.values_mut() {\n            for statement in \u0026mut block.statements {\n                match \u0026mut statement.operation {\n                    ir::Operations::Jump(jump) =\u003e {\n                        for target_arg in args_by_block.get(\u0026jump.destination_block).unwrap() {\n                            jump.block_args\n                                .insert(target_arg.clone(), target_arg.clone());\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n\n        let new_block_args = idfa::BlockArgs::new(\u0026function.control_flow).take_facts();\n        if new_block_args != block_args {\n            block_args = new_block_args;\n        } else {\n            break;\n        }\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","convert_reads.rs"],"content":"use std::collections::BTreeMap;\n\nuse crate::midend::{idfa::reaching_defs::IdfaImplementor, ir, symtab};\n\npub fn convert_reads_to_ssa(function: \u0026mut symtab::Function) {\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        let mut highest_ssa_numbers = BTreeMap::\u003cir::OperandName, ir::OperandName\u003e::new();\n\n        for arg in \u0026block.arguments {\n            highest_ssa_numbers.insert(arg.clone().into_non_ssa(), arg.clone());\n        }\n\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = match highest_ssa_numbers.get(read) {\n                    Some(operand) =\u003e operand.ssa_number,\n                    None =\u003e {\n                        println!(\"{} has no ssa number (yet)\", read);\n                        None\n                    }\n                };\n            }\n\n            for write in statement.write_operand_names() {\n                match highest_ssa_numbers.get(\u0026write.clone().into_non_ssa()) {\n                    Some(existing_number) =\u003e {\n                        assert!(existing_number.ssa_number.unwrap() \u003c write.ssa_number.unwrap());\n                    }\n                    None =\u003e {}\n                }\n                highest_ssa_numbers.insert(write.clone().into_non_ssa(), write.clone());\n            }\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","convert_writes.rs"],"content":"use std::{collections::HashMap, fmt::Display};\n\nuse crate::midend::{ir, symtab};\n\n#[derive(Debug)]\nstruct SsaWriteConversionMetadata {\n    variables: HashMap\u003cString, usize\u003e,\n}\n\nimpl Display for SsaWriteConversionMetadata {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut result: std::fmt::Result = write!(f, \"Variables: {{\");\n\n        for (variable, ssa_number) in \u0026self.variables {\n            result = result.and(writeln!(f, \"{}:{}\", variable, ssa_number));\n        }\n\n        result\n    }\n}\n\nimpl SsaWriteConversionMetadata {\n    pub fn new() -\u003e Self {\n        Self {\n            variables: HashMap::new(),\n        }\n    }\n\n    pub fn next_number_for_variable(\u0026mut self, operand_name: \u0026ir::OperandName) -\u003e usize {\n        let entry = self\n            .variables\n            .entry(operand_name.base_name.clone())\n            .or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n\n    pub fn next_number_for_string(\u0026mut self, string: String) -\u003e usize {\n        let entry = self.variables.entry(string).or_insert(0);\n        let returned_write = *entry;\n        *entry += 1;\n\n        returned_write\n    }\n}\n\nfn convert_block_writes_to_ssa(\n    block: \u0026mut ir::BasicBlock,\n    metadata: \u0026mut SsaWriteConversionMetadata,\n) {\n    let old_args = block.arguments.clone();\n    block.arguments.clear();\n\n    for argument in old_args.iter() {\n        let mut new_argument = argument.clone();\n        new_argument.ssa_number = Some(metadata.next_number_for_variable(argument));\n        block.arguments.insert(new_argument);\n    }\n\n    for statement in \u0026mut block.statements {\n        for write in statement.write_operand_names_mut() {\n            write.ssa_number = Some(metadata.next_number_for_variable(write));\n        }\n    }\n}\n\npub fn convert_writes_to_ssa(function: \u0026mut symtab::Function) {\n    let mut write_conversion_metadata = SsaWriteConversionMetadata::new();\n    for argument in \u0026function.prototype.arguments {\n        write_conversion_metadata.next_number_for_string(argument.name());\n    }\n\n    for (_, block) in function.control_flow.blocks_postorder_mut() {\n        convert_block_writes_to_ssa(block, \u0026mut write_conversion_metadata)\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","ssa_gen","mod.rs"],"content":"use std::collections::{BTreeSet, HashMap};\n\nuse add_block_args::add_block_arguments;\nuse convert_reads::convert_reads_to_ssa;\nuse convert_writes::convert_writes_to_ssa;\n\nmod add_block_args;\nmod convert_reads;\nmod convert_writes;\n\nuse super::{ir, symtab};\n\nfn convert_function_to_ssa(function: \u0026mut symtab::Function) {\n    add_block_arguments(function);\n    convert_writes_to_ssa(function);\n    convert_reads_to_ssa(function);\n\n    function.control_flow.to_graphviz();\n}\n\npub fn convert_functions_to_ssa(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function_or_prototype) in functions {\n        match function_or_prototype {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e convert_function_to_ssa(function),\n        };\n    }\n}\n\nfn remove_ssa_from_function(function: \u0026mut symtab::Function) {\n    for block in \u0026mut function.control_flow.blocks.values_mut() {\n        let old_arguments = block.arguments.clone();\n        block.arguments.clear();\n        block.arguments = BTreeSet::\u003cir::OperandName\u003e::new();\n        for arg in old_arguments {\n            block.arguments.insert(arg.into_non_ssa());\n        }\n        for statement in \u0026mut block.statements {\n            for read in statement.read_operand_names_mut() {\n                read.ssa_number = None;\n            }\n\n            for write in statement.write_operand_names_mut() {\n                write.ssa_number = None;\n            }\n        }\n    }\n    function.control_flow.to_graphviz();\n}\n\npub fn remove_ssa_from_functions(functions: \u0026mut HashMap\u003cString, symtab::FunctionOrPrototype\u003e) {\n    for (_, function) in functions {\n        match function {\n            symtab::FunctionOrPrototype::Prototype(_) =\u003e {}\n            symtab::FunctionOrPrototype::Function(function) =\u003e remove_ssa_from_function(function),\n        };\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","symtab.rs"],"content":"use crate::midend::types::Type;\nuse std::collections::HashMap;\n\nuse serde::Serialize;\nuse std::fmt::Display;\n\nuse super::ir;\n\n#[derive(Clone, Debug, Serialize)]\npub struct Variable {\n    name: String,\n    mangled_name: Option\u003cString\u003e,\n    type_: Type,\n}\n\nimpl Display for Variable {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} {}\", self.type_, self.name)\n    }\n}\n\nimpl Variable {\n    pub fn new(name: String, type_: Type) -\u003e Self {\n        Variable {\n            name,\n            mangled_name: None,\n            type_,\n        }\n    }\n\n    pub fn add_mangled_name(\u0026mut self, scope_indices: \u0026Vec\u003cusize\u003e) {\n        let mut mangled_name = String::new();\n        for scope in scope_indices {\n            mangled_name.push_str(\u0026(scope.to_string() + \u0026String::from(\"_\")));\n        }\n        mangled_name.push_str(\u0026self.name.clone());\n\n        match \u0026self.mangled_name {\n            Some(current_name) =\u003e {\n                panic!(\n                \"Variable {} already has mangled name {}, can't add_mangled_name with new name {}\",\n                self.name,\n                current_name,\n                mangled_name)\n            }\n            None =\u003e self.mangled_name.replace(mangled_name),\n        };\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        match \u0026self.mangled_name {\n            Some(mangled_name) =\u003e mangled_name.clone(),\n            None =\u003e self.name.clone(),\n        }\n    }\n\n    pub fn type_(\u0026self) -\u003e \u0026Type {\n        \u0026self.type_\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Scope {\n    subscope_indices: Vec\u003cusize\u003e,\n    variables: HashMap\u003cString, Variable\u003e,\n    subscopes: Vec\u003cScope\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Scope {\n            subscope_indices: Vec::new(),\n            variables: HashMap::new(),\n            subscopes: Vec::new(),\n        }\n    }\n\n    pub fn insert_variable(\u0026mut self, mut variable: Variable) {\n        variable.add_mangled_name(\u0026self.subscope_indices);\n        self.variables.insert(variable.name.clone(), variable);\n    }\n\n    pub fn lookup_variable_by_name(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Variable\u003e {\n        self.variables.get(name)\n    }\n\n    pub fn insert_subscope(\u0026mut self, subscope: Scope) {\n        self.subscopes.push(subscope);\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct FunctionPrototype {\n    pub name: String,\n    pub arguments: Vec\u003cVariable\u003e,\n    pub return_type: Option\u003cType\u003e,\n}\n\nimpl Display for FunctionPrototype {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut arguments_string = String::new();\n        for argument in \u0026self.arguments {\n            if arguments_string.len() \u003e 0 {\n                arguments_string = format!(\"{}, {}\", arguments_string, argument);\n            } else {\n                arguments_string = format!(\"{}\", argument);\n            }\n        }\n        match \u0026self.return_type {\n            Some(return_type) =\u003e write!(\n                f,\n                \"fun {}({}) -\u003e {}\",\n                self.name, arguments_string, return_type\n            ),\n            None =\u003e write!(f, \"fun {}({})\", self.name, arguments_string),\n        }\n    }\n}\n\nimpl FunctionPrototype {\n    pub fn new(name: String, arguments: Vec\u003cVariable\u003e, return_type: Option\u003cType\u003e) -\u003e Self {\n        FunctionPrototype {\n            name,\n            arguments,\n            return_type,\n        }\n    }\n\n    pub fn create_argument_scope(\u0026mut self) -\u003e Scope {\n        let mut arg_names: Vec\u003cString\u003e = Vec::new();\n        let mut argument_scope = Scope::new();\n        for arg in \u0026self.arguments {\n            arg_names.push(arg.name.clone());\n            argument_scope.insert_variable(arg.clone())\n        }\n\n        argument_scope\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct Function {\n    pub prototype: FunctionPrototype,\n    pub scope: Scope,\n    pub control_flow: ir::ControlFlow,\n}\n\nimpl Function {\n    pub fn new(prototype: FunctionPrototype, scope: Scope, control_flow: ir::ControlFlow) -\u003e Self {\n        Function {\n            prototype,\n            scope,\n            control_flow,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e String {\n        self.prototype.name.clone()\n    }\n}\n\n#[derive(Debug, Serialize)]\npub enum FunctionOrPrototype {\n    Function(Function),\n    Prototype(FunctionPrototype),\n}\n\n#[derive(Debug, Serialize)]\npub struct SymbolTable {\n    pub global_scope: Scope,\n    pub functions: HashMap\u003cString, FunctionOrPrototype\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        SymbolTable {\n            global_scope: Scope::new(),\n            functions: HashMap::new(),\n        }\n    }\n\n    pub fn assign_program_points(\u0026mut self) {\n        // TODO: re-enable this when SSA implemented\n        // for function in self.functions.values_mut() {\n        //     match function {\n        //         FunctionOrPrototype::Function(f) =\u003e {\n        //             f.control_flow_mut().assign_program_points();\n        //             let mut reaching_defs = ReachingDefs::new(f.control_flow());\n        //             reaching_defs.analyze();\n        //             reaching_defs.print();\n        //         }\n        //         FunctionOrPrototype::Prototype(_) =\u003e {}\n        //     }\n        // }\n    }\n\n    pub fn print_ir(\u0026self) {\n        for function in self.functions.values() {\n            match function {\n                FunctionOrPrototype::Function(f) =\u003e {\n                    println!(\"{}\", f.prototype);\n                }\n                FunctionOrPrototype::Prototype(_) =\u003e {}\n            }\n        }\n    }\n\n    pub fn insert_function(\u0026mut self, function: Function) {\n        self.functions\n            .insert(function.name(), FunctionOrPrototype::Function(function));\n    }\n\n    pub fn insert_function_prototype(\u0026mut self, prototype: FunctionPrototype) {\n        self.functions.insert(\n            prototype.name.clone(),\n            FunctionOrPrototype::Prototype(prototype),\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":71},{"path":["/","Users","mitch","substratum","rust-rewrite","src","midend","types.rs"],"content":"use serde::Serialize;\nuse std::fmt::Display;\n\n// #[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize)]\n// pub struct BasicTypeInfo {\n//     pointer_level: usize,\n// }\n\n// impl Display for BasicTypeInfo {\n//     fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n//         let mut pointer_string = String::new();\n//         for _ in 0..self.pointer_level {\n//             pointer_string.push('*');\n//         }\n//         write!(f, \"{}\", pointer_string)\n//     }\n// }\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Serialize, serde::Deserialize)]\npub enum Mutability {\n    Mutable,\n    Immutable,\n}\n\nimpl Display for Mutability {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Mutability::Mutable =\u003e write!(f, \"mut\"),\n            Mutability::Immutable =\u003e std::fmt::Result::Ok(()),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, Debug, Serialize, serde::Deserialize)]\npub enum Type {\n    U8,\n    U16,\n    U32,\n    U64,\n    I8,\n    I16,\n    I32,\n    I64,\n    Reference(Mutability, Box\u003cType\u003e),\n    Pointer(Mutability, Box\u003cType\u003e),\n}\n\nimpl Display for Type {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::U8 =\u003e write!(f, \"u8\"),\n            Self::U16 =\u003e write!(f, \"u16\"),\n            Self::U32 =\u003e write!(f, \"u32\"),\n            Self::U64 =\u003e write!(f, \"u64\"),\n            Self::I8 =\u003e write!(f, \"i8\"),\n            Self::I16 =\u003e write!(f, \"i16\"),\n            Self::I32 =\u003e write!(f, \"i32\"),\n            Self::I64 =\u003e write!(f, \"i64\"),\n            Self::Reference(mutability, to) =\u003e write!(f, \"\u0026{} {}\", mutability, to),\n            Self::Pointer(mutability, to) =\u003e write!(f, \"*{} {}\", mutability, to),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":16}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>